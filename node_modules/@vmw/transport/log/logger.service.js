/*
 * Copyright 2017-2020 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { LogChannel, LogLevel, LogObject } from './logger.model';
import { GeneralUtil } from '../util/util';
/**
 * This is the low-lever logger that can be instantiated and destroyed at will. Syslog maintains one of these
 * for use across the application, however, anyone can create an instance of this service and manage independent
 * Log Levels and output.
 */
export class Logger {
    constructor() {
        this._dateCss = 'color: blue;';
        this._fromCss = 'color: green';
        this._normalCss = 'color: black;';
        this._errorCss = 'color: red;';
        this._warnCss = 'color: orange;';
        this._infoCss = 'color: brown;';
        this._debugCss = 'color: black;';
        this._verboseCss = 'color: cyan;';
        /* dark theme friendly colors */
        this.dateCssDark = 'color: #ec96fb;';
        this.fromCssDark = 'color: #FF9800;';
        this.normalCssDark = 'color: #03a9f4';
        this.errorCssDark = 'color: red;';
        this.warnCssDark = 'color: orange;';
        this.infoCssDark = 'color: #03a9f4';
        this.debugCssDark = 'color: #03a9f4';
        this.verboseCssDark = 'color: #03a9f4';
        this._suppress = false;
        this._silent = false;
        this._styledLogsSupported = true;
        this.useDarkThemeFriendlyColors = true;
    }
    get dateCss() { return this._dateCss; }
    get fromCss() { return this._fromCss; }
    get normalCss() { return this._normalCss; }
    get errorCss() { return this._errorCss; }
    get warnCss() { return this._warnCss; }
    get infoCss() { return this._infoCss; }
    get debugCss() { return this._debugCss; }
    get verboseCss() { return this._verboseCss; }
    setStylingVisble(flag) {
        this._styledLogsSupported = flag;
    }
    useDarkTheme(flag) {
        this.useDarkThemeFriendlyColors = flag;
        if (this.useDarkThemeFriendlyColors) {
            this._dateCss = this.dateCssDark;
            this._fromCss = this.fromCssDark;
            this._normalCss = this.normalCssDark;
            this._errorCss = this.errorCssDark;
            this._warnCss = this.warnCssDark;
            this._infoCss = this.infoCssDark;
            this._debugCss = this.debugCssDark;
            this._verboseCss = this.verboseCssDark;
        }
    }
    /**
     * Turn of all logging
     */
    turnOffAllLogging() {
        this.silent(true);
        this.suppress(true);
        this.logLevel = LogLevel.Off;
    }
    /**
     * Turn on all logging
     * Defaults to LogLevel.ERROR; Errors and critical issues only.
     */
    turnOnAllLogging() {
        this.silent(false);
        this.suppress(false);
        this.logLevel = LogLevel.Error;
    }
    /**
     * Turn on VERBOSE logging
     */
    turnOnVerboseLogging() {
        this.turnOnAllLogging();
        this.logLevel = LogLevel.Verbose;
    }
    /**
     * Turn on DEBUG logging
     */
    turnOnDebugLogging() {
        this.turnOnAllLogging();
        this.logLevel = LogLevel.Debug;
    }
    /**
     * Turn on INFO logging
     */
    turnOnInfoLogging() {
        this.turnOnAllLogging();
        this.logLevel = LogLevel.Info;
    }
    /**
     * Turn on WARN logging
     */
    turnOnWarnLogging() {
        this.turnOnAllLogging();
        this.logLevel = LogLevel.Warn;
    }
    /**
     * Turn on ERROR logging
     */
    turnOnErrorLogging() {
        this.turnOnAllLogging();
        this.logLevel = LogLevel.Error;
    }
    /**
     * Returns the last item logged.
     *
     * @returns {string}
     */
    last() {
        return this._lastLog;
    }
    /**
     * Clear the last log
     */
    clear() {
        this._lastLog = '';
    }
    /**
     * Sets the minimum level of logging.
     *
     * @param level
     */
    set logLevel(level) {
        this._logLevel = level;
    }
    get logLevel() {
        return this._logLevel;
    }
    get stylingVisble() {
        return this._styledLogsSupported;
    }
    suppress(flag) {
        this._suppress = flag;
    }
    silent(flag) {
        this._silent = flag;
    }
    /**
     * Log if the minimum is at or below LogLevel.verbose
     *
     * @param object
     * @param from optional caller filename
     */
    verbose(object, from) {
        this.log(new LogObject().build(LogLevel.Verbose, LogChannel.channel, object, from, this._suppress));
    }
    /**
     * Log if the minimum is at or below LogLevel.debug
     *
     * @param object
     * @param from optional caller filename
     */
    debug(object, from) {
        this.log(new LogObject().build(LogLevel.Debug, LogChannel.channel, object, from, this._suppress));
    }
    /**
     * Log if the minimum is at or below LogLevel.info
     *
     * @param object
     * @param from optional caller filename
     */
    info(object, from) {
        this.log(new LogObject().build(LogLevel.Info, LogChannel.channel, object, from, this._suppress));
    }
    /**
     * Log if the minimum is at or below LogLevel.warn
     *
     * @param object
     * @param from optional caller filename
     */
    warn(object, from) {
        this.log(new LogObject().build(LogLevel.Warn, LogChannel.channel, object, from, this._suppress));
    }
    /**
     * Log if the minimum is at or below LogLevel.error
     *
     * @param object
     * @param from optional caller filename
     */
    error(object, from) {
        this.log(new LogObject().build(LogLevel.Error, LogChannel.channel, object, from, this._suppress));
    }
    /**
     * Log always
     *
     * @param object
     * @param from optional caller filename
     */
    always(object, from) {
        this.log(new LogObject().build(LogLevel.Off, LogChannel.channel, object, from));
    }
    group(logLevel, label, suppress = this._suppress) {
        if (logLevel < this.logLevel || suppress) {
            return;
        }
        console.groupCollapsed(label);
    }
    groupEnd(logLevel) {
        if (logLevel < this.logLevel || this._suppress) {
            return;
        }
        console.groupEnd();
    }
    outputWithOptionalStyle(fn, output, severityCss) {
        let consoleArgs = [output];
        if (this._styledLogsSupported) {
            consoleArgs = consoleArgs.concat(this.dateCss, this.fromCss, severityCss);
        }
        fn.apply(console, consoleArgs);
    }
    log(logObject) {
        if (logObject.logLevel < this.logLevel) {
            return;
        }
        if (logObject.caller) {
            this._lastLog = '[' + logObject.caller + ']: ' + logObject.object;
        }
        else {
            this._lastLog = logObject.object;
        }
        if (logObject.suppress) {
            return;
        }
        if (this._silent) {
            return;
        }
        let payloadIsObject = false;
        if (GeneralUtil.isObject(logObject.object)) {
            payloadIsObject = true;
        }
        let date = new Date().toLocaleTimeString();
        let output = '%c' + logObject.object;
        if (logObject.caller) {
            output += '%c [' + logObject.caller + ']%c';
            output += ' (' + date + ')';
        }
        else {
            output += '%c%c';
        }
        if (!this._styledLogsSupported) {
            output = output.replace(/%c/g, '');
        }
        switch (logObject.logLevel) {
            case LogLevel.Error:
                if (!payloadIsObject) {
                    output = '⁉️ [Error]: ' + output;
                }
                this.outputWithOptionalStyle(console.error, output, this.errorCss);
                break;
            case LogLevel.Warn:
                if (!payloadIsObject) {
                    output = '⚠️ [Warn]: ' + output;
                }
                this.outputWithOptionalStyle(console.warn, output, this.warnCss);
                break;
            case LogLevel.Info:
                if (!payloadIsObject) {
                    output = '▫️️ [Inf]: ' + output;
                }
                this.outputWithOptionalStyle(console.log, output, this.infoCss);
                break;
            case LogLevel.Debug:
                if (!payloadIsObject) {
                    output = '🔸 [Deb]: ' + output;
                }
                this.outputWithOptionalStyle(console.log, output, this.debugCss);
                break;
            case LogLevel.Verbose:
                if (!payloadIsObject) {
                    output = '📍️ [Ver]: ' + output;
                }
                this.outputWithOptionalStyle(console.log, output, this.verboseCss);
                break;
            // default:
            //     this.outputWithOptionalStyle(console.log, output, this.normalCss);
            //     break;
        }
    }
}
//# sourceMappingURL=logger.service.js.map