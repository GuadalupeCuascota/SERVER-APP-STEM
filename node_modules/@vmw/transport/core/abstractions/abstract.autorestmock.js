/*
 * Copyright 2018-2019 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { AbstractAutoService } from './abstract.autoservice';
import { SERVICE_ERROR } from './abstract.service';
import { RestService } from '../services/rest/rest.service';
import { HttpRequest, RestError } from '../services/rest/rest.model';
export const MOCK_FAKE_ERROR = 400;
export const MOCK_UNIMPLEMENTED_ERROR = 444;
/**
 * This is the abstract class for deriving xxx.autorest.mock.ts files in all the services.
 */
export class AbstractAutoRestMock extends AbstractAutoService {
    constructor(name, listensTo) {
        super(name, RestService.channel);
        this.mustFail = false;
        this.name = 'AbstractAutoRestMock';
        this.restError = new RestError('Fake Error.', MOCK_FAKE_ERROR, 'fakeUri');
        this.debug = false;
        this.name = name;
        this.listensTo = listensTo;
        this.log.info(`♣️ Mock RestService Booted: ${name} with id: ${this.id}`, this.getName());
    }
    /**
     * Check if there is a forced response without popping the stack
     */
    get hasForceResponse() {
        return !!this.pvtForceResponse;
    }
    /**
     * Push a response onto the stack. If a NULL is passed, set the stack to undefined.
     *
     * @param response any
     */
    set forceResponse(response) {
        if (!response) {
            this.pvtForceResponse = undefined;
            return;
        }
        if (!this.pvtForceResponse) {
            this.pvtForceResponse = [];
        }
        this.pvtForceResponse.push(response);
    }
    /**
     * Return the value at the top of the stack. Pop the stack unless there is only one element in the stack.
     */
    get forceResponse() {
        return this.pvtForceResponse && this.pvtForceResponse.length > 1
            ? this.pvtForceResponse.pop()
            : this.pvtForceResponse[0];
    }
    /**
     * Check if there is a forced error without popping the stack
     */
    get hasForceError() {
        return !!this.pvtForceError;
    }
    /**
     * Push a error onto the stack. If a NULL is passed, set the stack to undefined.
     *
     * @param error any
     */
    set forceError(error) {
        if (!error) {
            this.pvtForceError = undefined;
            return;
        }
        if (!this.pvtForceError) {
            this.pvtForceError = [];
        }
        this.pvtForceError.push(error);
    }
    /**
     * Return the value at the top of the stack. Pop the stack unless there is only one element in the stack.
     */
    get forceError() {
        return this.pvtForceError && this.pvtForceError.length > 1
            ? this.pvtForceError.pop()
            : this.pvtForceError[0];
    }
    handleData(data, restObject, args) {
        restObject.response = data;
        if (args) {
            this.bus.sendResponseMessageWithId(RestService.channel, restObject, args.uuid, this.getName());
        }
        else {
            this.bus.sendResponseMessage(RestService.channel, restObject, this.getName());
        }
    }
    handleError(err, restObject, args) {
        if (args) {
            this.bus.sendErrorMessageWithId(RestService.channel, err, args.uuid, this.getName());
        }
        else {
            this.bus.sendErrorMessage(RestService.channel, err, this.getName());
        }
    }
    unhandledError(restRequestObject, apiClass) {
        const errMsg = this.name + ': Unhandled API Class (' + apiClass + ') request: ' + restRequestObject.request;
        this.log.error(errMsg);
        this.handleError(new RestError(errMsg, MOCK_UNIMPLEMENTED_ERROR, ''), restRequestObject);
    }
    handleServiceRequest(restRequestObject, requestArgs) {
        // ignore requestors that are not from "our" service
        if (restRequestObject.senderName !== this.listensTo) {
            return;
        }
        // handle forced backend custom error
        if (this.hasForceError) {
            this.handleError(this.forceError, restRequestObject, requestArgs);
            return;
        }
        // handle forced backend error
        if (this.mustFail) {
            this.handleError(this.restError, restRequestObject, requestArgs);
            return;
        }
        // This allows a specific response to be sent back
        if (this.hasForceResponse) {
            this.handleData(this.forceResponse, restRequestObject, requestArgs);
            return;
        }
        switch (restRequestObject.request) {
            case HttpRequest.Get:
                this.httpGet(restRequestObject, requestArgs);
                break;
            case HttpRequest.Post:
                this.httpPost(restRequestObject, requestArgs);
                break;
            case HttpRequest.Put:
                this.httpPut(restRequestObject, requestArgs);
                break;
            case HttpRequest.Patch:
                this.httpPatch(restRequestObject, requestArgs);
                break;
            case HttpRequest.Delete:
                this.httpDelete(restRequestObject, requestArgs);
                break;
            default:
                this.restError = new RestError(this.getName() + ': Unknown request: '
                    + restRequestObject.request, SERVICE_ERROR, 'fakeUri');
                this.handleError(this.restError, restRequestObject, requestArgs);
        }
    }
    unimplemented(f, r) {
        this.log.error(this.getName() + ' Unimplemented mock handler for HTTP ' + f + '!' + r);
    }
    // These should be overridden in the derived class
    httpGet(restRequestObject, args) {
        this.unimplemented('GET', restRequestObject);
    }
    httpPost(restRequestObject, args) {
        this.unimplemented('POST', restRequestObject);
    }
    httpPut(restRequestObject, args) {
        this.unimplemented('PUT', restRequestObject);
    }
    httpPatch(restRequestObject, args) {
        this.unimplemented('PATCH', restRequestObject);
    }
    httpDelete(restRequestObject, args) {
        this.unimplemented('DELETE', restRequestObject);
    }
}
//# sourceMappingURL=abstract.autorestmock.js.map