import { ChannelName, MessageArgs, MessageHandler, SentFrom } from '../../bus.api';
import { AbstractBase } from './abstract.base';
import { HttpRequest, RestError } from '../services/rest/rest.model';
import { APIRequest } from '../model/request.model';
import { UUID } from '../../bus';
import { GeneralError } from '../model/error.model';
import { ApiObject } from './abstract.apiobject';
import { AbstractMessageObject } from './abstract.messageobject';
import { Subscription } from 'rxjs';
import { FabricService } from './fabric.service';
export declare const SERVICE_ERROR = 505;
export declare type RequestorArguments = MessageArgs;
declare type SuccessHandler = (apiObject: ApiObject<any, any>, response: any, requestArgs?: MessageArgs) => void;
declare type ErrorHandler = (apiObject: ApiObject<any, any>, err: RestError, requestArgs?: MessageArgs) => void;
declare type ApiFunction = (apiObject: ApiObject<any, any>, httpOp: string, uri: string, body: any, successHandler: SuccessHandler, failureHandler: ErrorHandler, apiClass: string, apiArgs?: MessageArgs) => void;
declare type CallSuccessHandler = (response: AbstractMessageObject<any, any>, args?: MessageArgs) => void;
declare type CallFailureHandler = (error: RestError, args?: MessageArgs) => void;
declare type ServiceCallFunction = (requestChannel: string, requestObject: AbstractMessageObject<any, any>, successHandler: CallSuccessHandler, failureHandler: CallFailureHandler, messageArgs: MessageArgs) => void;
/**
 * This class extends MessageArgs in order to be able to pass state to the handler lambda
 */
export declare class CallerArgs implements MessageArgs {
    uuid: UUID;
    from: SentFrom;
    version: number;
    constructor(uuid: UUID, from?: SentFrom, version?: number);
}
/**
 * This is an abstract service that encapsulates messagebus handling and implements some
 * of the more commonly used methods by the derived services. The derived classes provide
 * handlers for when a all is received or when there is a response from a ReST all.
 * The error handler can be overridden in the derived class.
 *
 * ReqT is the type of the all payload to the service (e.g. RolesRequestObject)
 * RespT is the type of the response payload from the service (e.g. RolesResponseObject)
 */
export declare abstract class AbstractService<ReqT, RespT> extends AbstractBase implements FabricService {
    protected serviceError: RestError;
    protected apiBridge: ApiFunction;
    protected apiSuccessHandler: SuccessHandler;
    protected apiFailureHandler: ErrorHandler;
    protected serviceCall: ServiceCallFunction;
    protected requestConverterMap: Map<string, HttpRequest>;
    protected readonly serviceChannel: ChannelName;
    protected readonly broadcastChannel: ChannelName;
    protected $host: string | undefined;
    protected requestStream: MessageHandler;
    protected requestStreamSub: Subscription;
    readonly id: UUID;
    /**
     * super()
     *
     * @param name - name of the derived service (e.g. 'task.service'
     * @param serviceChannel - channel on which to listen for requests and send responses for the derived service
     * @param broadcastChannel - channel on which to broadcast for all listeners.
     */
    protected constructor(name: string, serviceChannel: ChannelName, broadcastChannel?: ChannelName);
    private listenToRequestStream;
    protected abstract handleServiceRequest(requestObject: ReqT, requestArgs?: MessageArgs): void;
    /**
     * RestError to use for invalid requests
     *
     * @returns {RestError}
     */
    protected get serviceRequestError(): RestError;
    /**
     *  Method to send a response object to the client of the service
     * @param {string} channel to respond to
     * @param {any} responseObject response object to send
     * @param {MessageArgs} args optional arguments to pass.
     */
    protected postResponse(channel: string, responseObject: any, args?: MessageArgs): void;
    /**
     * Method to send a RestError to the client of the service
     * @param {string} channel channel to sent error to.
     * @param {RestError} err returned from rest service.
     * @param {MessageArgs} args optional arguments to pass.
     */
    protected postError(channel: string, err: GeneralError, args?: MessageArgs): void;
    /**
     * Build a API request command object
     *
     * @param {string} requestCommand
     * @param {T} payload
     * @param {UUID} uuid
     * @param {number} version
     * @returns {APIRequest<T>}
     */
    protected buildAPIRequest<T>(requestCommand: string, payload: T, uuid?: UUID, version?: number): APIRequest<T>;
    /**
     * The "serviceCall" lambda is used to send messages between services, abstracting the message bus.
     */
    private initializeServiceCallHandling;
    /**
     * Initialize lambda function context for use by the API layer autogenerated by "apigen"
     *
     * In order to pass functions around in a typesafe fashion while preserving 'this', is to use lambdas, which
     * preserves the context of protected functions, and unlike bind(), does not lose the type information.
     * Basically, the lambda is stored in a class variable that can be passed around at will and be invoked exactly
     * like a function reference. This solves the non-intuitive handling of 'this' by javascript.
     */
    private initializeApiHandling;
    /**
     * Required for any VMware Cloud Services API.
     */
    protected get callerOrgId(): string;
    /**
     * Helper function to generate an API object
     *
     * @param requestObject
     * @param responseObject
     */
    protected genApiObject(requestObject: AbstractMessageObject<any, any>, responseObject: AbstractMessageObject<any, any>): ApiObject<any, any>;
    /**
     * Broadcast message to all subscribers on channel.
     * @param channel
     * @param payload
     */
    protected broadcastResponse(channel: string, payload: any): void;
    /**
     * Alias for broadcastResponse()
     *
     * @param channel
     * @param notification
     */
    protected broadcastNotification<N>(channel: string, notification: N): void;
    /**
     * Knock the service offline.
     */
    offline(): void;
    /**
     * Bring service online.
     */
    online(): void;
}
export {};
