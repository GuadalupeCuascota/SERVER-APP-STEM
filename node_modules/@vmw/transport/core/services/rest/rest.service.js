/*
 * Copyright 2018-2020 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { HttpRequest, RestError, RestErrorType } from './rest.model';
import { LogLevel } from '../../../log';
import { AbstractCore } from '../../abstractions/abstract.core';
import { TransportHttpclient } from './transport.httpclient';
import { GLOBAL_HEADERS, GLOBAL_HEADERS_UPDATE, HEADERS_STORE } from '../../../fabric/fabric';
const REFRESH_RETRIES = 3;
export var RequestCorsMode;
(function (RequestCorsMode) {
    RequestCorsMode["SAME_ORIGIN"] = "same-origin";
    RequestCorsMode["NO_CORS"] = "no-cors";
    RequestCorsMode["CORS"] = "cors";
    RequestCorsMode["NAVIGATE"] = "navigate";
})(RequestCorsMode || (RequestCorsMode = {}));
export var RequestCredentialsMode;
(function (RequestCredentialsMode) {
    RequestCredentialsMode["OMIT"] = "omit";
    RequestCredentialsMode["SAME_ORIGIN"] = "same-origin";
    RequestCredentialsMode["INCLUDE"] = "include";
})(RequestCredentialsMode || (RequestCredentialsMode = {}));
/**
 * REST Service that operates standard functions on behalf of consumers and services.
 */
export class RestService extends AbstractCore {
    constructor(httpClient) {
        super();
        this.name = 'RESTService';
        this.corsMode = 'cors';
        this.credentialsMode = 'same-origin';
        this.disableCorsAndCredentials = false;
        this.isRestService = true; // need this because rest service gets munged in production.
        if (!httpClient) {
            this.httpClient = new TransportHttpclient();
        }
        else {
            this.httpClient = httpClient;
        }
        this.headerStore = this.storeManager.createStore(HEADERS_STORE);
        this.listenForRequests();
        this.log.info(`${this.name} Online`);
        // leave this configurable by consumer, defaults to same host/scheme as hosted UI.
        this.globalBaseUri = '';
    }
    getName() {
        return this.name;
    }
    listenForRequests() {
        this.restStream = this.bus.listenRequestStream(RestService.channel);
        this.restStream.handle((restObject, args) => {
            // configure refresh.
            restObject.refreshRetries = 0;
            if (restObject.request !== HttpRequest.UpdateGlobalHeaders
                && restObject.request !== HttpRequest.SetRestServiceHostOptions
                && restObject.request !== HttpRequest.DisableCORSAndCredentials
                && restObject.request !== HttpRequest.ConfigureCORSAndCredentials) {
                this.doHttpRequest(restObject, args);
            }
            else {
                switch (restObject.request) {
                    case HttpRequest.UpdateGlobalHeaders:
                        this.updateHeaders(restObject.headers);
                        break;
                    case HttpRequest.SetRestServiceHostOptions:
                        this.updateHostOptions(restObject.uri);
                        break;
                    case HttpRequest.DisableCORSAndCredentials:
                        this.disableCORS(true);
                        break;
                    case HttpRequest.ConfigureCORSAndCredentials:
                        this.updateCorsModeAndCredentials(restObject.body);
                        break;
                    default:
                        break;
                }
            }
        });
    }
    updateHeaders(headers) {
        this.log.info(`Updating global headers for outbound request: ${headers}`, this.getName());
        this.headerStore.put(GLOBAL_HEADERS, headers, GLOBAL_HEADERS_UPDATE);
    }
    updateHostOptions(uri) {
        this.log.info(`Updating global base URI to: ${uri}`, this.getName());
        this.globalBaseUri = uri;
    }
    disableCORS(val) {
        this.log.info(`Disabling CORS and credentials`, this.getName());
        this.disableCorsAndCredentials = val;
    }
    updateCorsModeAndCredentials(body) {
        this.log.info(`Configuring CORS mode and credentials with CORS mode: ${body.corsMode}, credentials mode: ${body.credentialsMode}`, this.getName());
        this.corsMode = body.corsMode;
        this.credentialsMode = body.credentialsMode;
    }
    handleData(data, restObject, args) {
        this.log.group(LogLevel.Verbose, 'REST APIRequest ' + restObject.request + ' ' + restObject.uri);
        this.log.verbose('** Received response: ' + data, this.getName());
        this.log.verbose('** APIRequest was: ' + restObject, this.getName());
        this.log.verbose('** Headers were: ' + this.headers, this.getName());
        this.log.groupEnd(LogLevel.Verbose);
        // set response in rest request object
        restObject.response = data;
        // send the object back to whomever was listening for this specific request.
        this.bus.sendResponseMessageWithIdAndVersion(RestService.channel, restObject, args.uuid, args.version, this.getName());
    }
    handleError(error, restObject, args) {
        if (error) {
            this.log.group(LogLevel.Error, 'Http Error: ' + restObject.request + ' ' +
                restObject.uri + ' -' + ' ' + error.status);
            this.log.error(error, this.getName());
            this.log.error('** APIRequest was: ' + restObject.body, this.getName());
            this.log.error('** Headers were: ' + this.headers, this.getName());
            this.log.groupEnd(LogLevel.Error);
            this.bus.sendErrorMessageWithIdAndVersion(RestService.channel, error, args.uuid, args.version, this.getName());
        }
        else {
            this.bus.sendErrorMessageWithIdAndVersion(RestService.channel, 'Http request failed, unknown error', args.uuid, args.version, this.getName());
        }
    }
    doHttpRequest(restObject, args) {
        // handle rest response
        const successHandler = (response) => {
            this.handleData(response, restObject, args);
        };
        const errorHandler = (response) => {
            this.handleError(response, restObject, args);
        };
        const globalHeaders = this.headerStore.get(GLOBAL_HEADERS);
        // merge globals and request headers
        const requestHeaders = Object.assign(Object.assign({}, globalHeaders), restObject.headers);
        // set XSRF token if it is enabled
        if (this.fabric.isXsrfTokenEnabled()) {
            requestHeaders[this.fabric.getXsrfTokenStoreKey()] = this.fabric.getXsrfToken();
        }
        this.log.debug(`Rest Service: preparing headers ${requestHeaders}`, this.getName());
        // generate fetch headers, init and request objects.
        const requestHeadersObject = new Headers(requestHeaders);
        const requestInit = this.generateRequestInitObject(restObject, requestHeadersObject);
        let httpRequest;
        // try to create fetch request.
        try {
            const uri = this.globalBaseUri + restObject.uri;
            this.log.debug(`Rest Service: Preparing Fetch Request for URI: ${uri}`, this.getName());
            httpRequest = new Request(uri);
        }
        catch (e) {
            this.log.error(`Rest Service: Cannot create request: ${e}`, this.getName());
            this.handleError(new RestError('Invalid HTTP request.', RestErrorType.UnknownMethod, restObject.uri), restObject, args);
            return;
        }
        switch (restObject.request) {
            case HttpRequest.Get:
                this.httpClient.get(httpRequest.url, requestInit, successHandler, errorHandler);
                break;
            case HttpRequest.Post:
                this.httpClient.post(httpRequest.url, requestInit, successHandler, errorHandler);
                break;
            case HttpRequest.Patch:
                this.httpClient.patch(httpRequest.url, requestInit, successHandler, errorHandler);
                break;
            case HttpRequest.Put:
                this.httpClient.put(httpRequest.url, requestInit, successHandler, errorHandler);
                break;
            case HttpRequest.Delete:
                this.httpClient.delete(httpRequest.url, requestInit, successHandler, errorHandler);
                break;
            default:
                this.log.error(`Rest Service: Bad REST request: ${restObject.request}`, this.getName());
                this.handleError(new RestError('Invalid HTTP request.', RestErrorType.UnknownMethod, restObject.uri), restObject, args);
                return;
        }
    }
    generateRequestInitObject(restObject, headers) {
        let requestInit = {
            method: restObject.request,
            headers: headers,
            mode: this.corsMode,
            credentials: this.credentialsMode,
            referrerPolicy: 'origin-when-cross-origin',
        };
        // keeping it until the deprecated methods are removed.
        if (this.disableCorsAndCredentials) {
            this.log.warn('Use of disableCorsAndCredentials is deprecated and strongly discouraged. This will' +
                'conflict with the configurer method updateCorsModeAndCredentials().');
            requestInit.credentials = 'include';
        }
        // GET requests may not have a body
        if (restObject.request !== HttpRequest.Get) {
            try {
                // DELETE requests may also not have a body
                if (restObject.request === HttpRequest.Delete &&
                    !restObject.body.trim()) {
                    return requestInit;
                }
                // check if payload has already been stringified or not
                if (JSON.parse(restObject.body)) {
                    requestInit.body = restObject.body;
                }
            }
            catch (exp) {
                requestInit.body = JSON.stringify(restObject.body);
            }
        }
        return requestInit;
    }
    offline() {
        this.log.info(`RestService (Local / Browser): OFFLINE`, this.getName());
        this.restStream.close();
    }
    online() {
        this.log.info(`RestService (Local / Browser): ONLINE`, this.getName());
        this.listenForRequests();
    }
}
RestService.channel = 'fabric-rest';
//# sourceMappingURL=rest.service.js.map