/*
 * Copyright 2018-2020 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { LogLevel } from '../../../log';
import { BusTestUtil } from '../../../util/test.util';
import { ServiceLoader } from '../../../util/service.loader';
import { FakeService } from '../mocks/fake.service.mock';
import { RestService } from './rest.service';
import { MockHttpClient } from './httpclient.mock';
import { FakeApiCallRequestObject, FakeChannel, FakeGenericRequestObject, FakeGetServiceVersionRequestObject, FakeRequest, FakeRestRelayRequestObject } from '../mocks/service.objects.mock';
import { GeneralUtil } from '../../../util/util';
// These test the RestService and the autogeneration abstractions using FakeService
describe('Fake Service [services/rest/rest.service.spec]', () => {
    let bus;
    let log;
    let httpClient;
    const restPayloadGet = {
        op: 'GET',
        uri: 'http://some/uri',
        headers: { seven: 'eight' }
    };
    const restPayloadPost = {
        op: 'POST',
        uri: 'http://some/uri',
        body: { five: 'six' },
        headers: { seven: 'eight' }
    };
    let restService;
    beforeEach(() => {
        bus = BusTestUtil.bootBusWithOptions(LogLevel.Debug, true);
        bus.api.silenceLog(true);
        bus.api.suppressLog(true);
        bus.api.enableMonitorDump(false);
        log = bus.api.logger();
        httpClient = new MockHttpClient();
        httpClient.mustFail = false;
        httpClient.errCode = 200;
        restService = ServiceLoader.addService(RestService, httpClient);
        ServiceLoader.addService(FakeService);
    });
    afterEach(() => {
        ServiceLoader.destroyAllServices();
    });
    it('Should have loaded the Fake service mock and RestService with the mock httpClient.', () => {
        let services = ServiceLoader.getLoadedServices();
        expect(services.size).toEqual(2);
    });
    it('Should get version from FakeService.', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.id).toEqual(id);
            const responseObject = message.payload;
            const serviceVersion = responseObject.payload;
            expect(serviceVersion.isValid).toBeTruthy();
            expect(serviceVersion.name).toBe('FakeService');
            expect(serviceVersion.version).toBe('1');
        });
        const requestObject = new FakeGetServiceVersionRequestObject(FakeChannel.request);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should fail on a bad request to FakeService (negative test).', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.id).toEqual(id);
            expect(message.isError()).toBeTruthy();
        });
        const requestObject = new FakeGenericRequestObject(FakeChannel.request, FakeRequest.BadRequest);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should simulate an autogenerated API call.', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            const responseObject = message.payload;
            const response = responseObject.payload;
            expect(response).toBe('Fake Response');
        });
        const requestObject = new FakeApiCallRequestObject(FakeChannel.request, 'GET');
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should exercise postResponse without message args and buildAPIRequest().', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            const responseObject = message.payload;
            const api = responseObject.payload;
            expect(api.request).toBe('Fake request');
            expect(api.payload).toBe('Fake payload');
            expect(api.version).toBe(123);
        });
        const requestObject = new FakeApiCallRequestObject(FakeChannel.request, 'Fake Request');
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should simulate an autogenerated API call with Rest error (negative test).', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        httpClient.mustFail = true;
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.isError()).toBeTruthy();
        });
        const requestObject = new FakeApiCallRequestObject(FakeChannel.request, 'GET');
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should simulate an autogenerated API call with bad Rest op (negative test).', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.isError()).toBeTruthy();
        });
        const requestObject = new FakeApiCallRequestObject(FakeChannel.request, 'Bad Op');
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should send GET to the Rest service.', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadGet);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            const responseObject = message.payload;
            const payload = responseObject.payload;
            expect(payload).toBe('GET called');
        });
        packet['op'] = 'GET';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should fail on a GET to the Rest service with 401 (negative test).', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadGet);
        httpClient.mustFail = true;
        httpClient.errCode = 401;
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.id).toEqual(id);
            expect(message.isError()).toBeTruthy();
        });
        packet['op'] = 'GET';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should fail on a GET to the Rest service with something other than 401 (negative branch test).', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadGet);
        httpClient.mustFail = true;
        httpClient.errCode = 500;
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.id).toEqual(id);
            expect(message.isError()).toBeTruthy();
        });
        packet['op'] = 'GET';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should fail on a bad op to the Rest service (negative test).', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadGet);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.id).toEqual(id);
            expect(message.isError()).toBeTruthy();
        });
        packet['op'] = 'Bad Op';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should send POST to the Rest service.', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            const responseObject = message.payload;
            const payload = responseObject.payload;
            expect(payload).toBe('POST called');
        });
        packet['op'] = 'POST';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should send PUT to the Rest service.', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            const responseObject = message.payload;
            const payload = responseObject.payload;
            expect(payload).toBe('PUT called');
        });
        packet['op'] = 'PUT';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should send PATCH to the Rest service.', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            const responseObject = message.payload;
            const payload = responseObject.payload;
            expect(payload).toBe('PATCH called');
        });
        packet['op'] = 'PATCH';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should send DELETE to the Rest service.', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            const responseObject = message.payload;
            const payload = responseObject.payload;
            expect(payload).toBe('DELETE called');
        });
        packet['op'] = 'DELETE';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should simulate an autogenerated API call when no base url is provided', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadGet);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            const responseObject = message.payload;
            const payload = responseObject.payload;
            expect(payload).toBe('GET called');
        });
        packet['op'] = 'GET';
        packet['uri'] = '/foo';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should fail on a bad url passed to the Rest service (negative test).', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadGet);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.id).toEqual(id);
            expect(message.isError()).toBeTruthy();
        });
        packet['op'] = 'GET';
        packet['uri'] = 'https://';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should update headers.', () => {
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        expect(channel)
            .not
            .toBeUndefined();
        channel.subscribe((message) => {
            expect(message.isError()).toBeFalsy();
        });
        packet['op'] = 'UPDATE_HEADERS';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
    });
    it('Should update host options.', (done) => {
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        packet.uri = 'http://my.new.host';
        spyOn(bus.logger, 'info').and.callThrough();
        packet['op'] = 'HOST_OPTIONS';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
        bus.api.tickEventLoop(() => {
            expect(bus.logger.info)
                .toHaveBeenCalledWith('Updating global base URI to: http://my.new.host', 'RESTService');
            done();
        }, 50);
    });
    it('Should update CORS options.', (done) => {
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        packet.uri = 'http://my.new.host';
        spyOn(bus.logger, 'info').and.callThrough();
        packet['op'] = 'CORS_OPTIONS';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
        bus.api.tickEventLoop(() => {
            expect(bus.logger.info)
                .toHaveBeenCalledWith('Disabling CORS and credentials', 'RESTService');
            done();
        }, 50);
    });
    it('Should update CORS and credentials options.', (done) => {
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        spyOn(bus.logger, 'info').and.callThrough();
        packet['op'] = 'CORS_CREDENTIALS_OPTIONS';
        packet['body'] = { corsMode: 'cors', credentialsMode: 'include' };
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
        bus.api.tickEventLoop(() => {
            expect(bus.logger.info)
                .toHaveBeenCalledWith(`Configuring CORS mode and credentials with CORS mode: cors, credentials mode: include`, 'RESTService');
            done();
        }, 50);
    });
    it('Check service can go online', () => {
        spyOn(bus.logger, 'info').and.callThrough();
        const rs = ServiceLoader.getRestService();
        rs.online();
        expect(bus.logger.info).toHaveBeenCalledWith('RestService (Local / Browser): ONLINE', 'RESTService');
    });
    it('Check service can go offline', () => {
        spyOn(bus.logger, 'info').and.callThrough();
        const rs = ServiceLoader.getRestService();
        rs.offline();
        expect(bus.logger.info).toHaveBeenCalledWith('RestService (Local / Browser): OFFLINE', 'RESTService');
    });
    it('Check disableCorsAndCredentials deprecation warning shows up when invoked', (done) => {
        spyOn(bus.logger, 'warn').and.callThrough();
        let channel = bus.api.getResponseChannel(FakeChannel.request);
        const id = GeneralUtil.genUUIDShort();
        const packet = {};
        Object.assign(packet, restPayloadPost);
        packet['op'] = 'CORS_OPTIONS';
        const requestObject = new FakeRestRelayRequestObject(FakeChannel.request, packet);
        bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
        bus.api.tickEventLoop(() => {
            packet['op'] = 'POST';
            channel.subscribe(() => {
                expect(bus.logger.warn).toHaveBeenCalled();
                done();
            });
            bus.sendRequestMessageWithId(FakeChannel.request, requestObject, id);
        }, 10);
    });
});
//# sourceMappingURL=rest.service.spec.js.map