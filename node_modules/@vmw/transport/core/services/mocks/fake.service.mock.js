/*
 * Copyright 2018-2020 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { CallerArgs } from '../..';
import { AbstractAutoService } from '../../abstractions/abstract.autoservice';
import { FakeChannel, FakeGetServiceVersionResponseObject, FakeRequest, FakeApiCallResponseObject, FakeRestRelayResponseObject } from './service.objects.mock';
import { ServiceVersion } from '../../abstractions/service.version';
import { RestObject } from '../rest/rest.model';
import { RestService } from '../rest/rest.service';
import { GeneralUtil } from '../../../util/util';
// This fake service is written as Servgen would autogenerate it as a custom service stub.
// Its main purpose is to relay requests to RestService, while behaving as an autogenerated service
// that responds to GetVersion requests. It resends the response from RestService back to the service requestor.
export class FakeService extends AbstractAutoService {
    constructor() {
        super('FakeService', FakeChannel.request);
        this.version = '1';
    }
    handleServiceRequest(requestObject, requestArgs) {
        switch (requestObject.request) {
            case FakeRequest.RestRelay: {
                const relayRequestObject = requestObject;
                const payload = relayRequestObject.payload;
                const apiObject = this.genApiObject(relayRequestObject, new FakeRestRelayResponseObject({}));
                // Prepare the payload for RestService
                const restRequestObject = new RestObject(this.requestConverterMap.get(payload['op']), // HttpRequest
                payload['uri'], // URI
                payload['body'], // Body
                payload['headers'], // Headers
                {}, // Query Params
                {} // Path params
                );
                this.serviceCall(RestService.channel, restRequestObject, (restResponseObject, args) => {
                    this.apiSuccessHandler(apiObject, restResponseObject.response, args);
                }, (err) => {
                    this.apiFailureHandler(apiObject, err);
                }, new CallerArgs(GeneralUtil.genUUID(), this.getName()));
                break;
            }
            case FakeRequest.ApiCall: {
                const apiCallRequestObject = requestObject;
                const op = apiCallRequestObject.payload;
                const apiObject = this.genApiObject(apiCallRequestObject, new FakeApiCallResponseObject());
                if (op === 'Fake Request') { // send a message without message args
                    apiObject.responseObject.payload = this.buildAPIRequest('Fake request', 'Fake payload', GeneralUtil.genUUIDShort(), 123);
                    this.postResponse(FakeChannel.request, apiObject.responseObject);
                    break;
                }
                this.apiBridge(apiObject, op, // OP
                'some/uri', // URI
                { body: "fake body' " }, // Body
                (restObject, args) => {
                    restObject = 'Fake Response';
                    this.apiSuccessHandler(apiObject, restObject, args);
                }, (apiObjectReturned, err) => {
                    err = 'Fake Error';
                    this.apiFailureHandler(apiObjectReturned, err);
                }, 'Fake API Class');
                break;
            }
            case FakeRequest.GetServiceVersion: {
                const apiObject = this.genApiObject(requestObject, new FakeGetServiceVersionResponseObject(new ServiceVersion(this.getName(), this.version)));
                this.apiSuccessHandler(apiObject, new ServiceVersion(this.getName(), this.version), requestArgs);
                break;
            }
            default:
                this.postError(requestObject.channel, this.serviceRequestError, requestArgs);
        }
    }
}
//# sourceMappingURL=fake.service.mock.js.map