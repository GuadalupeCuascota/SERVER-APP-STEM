/*
 * Copyright 2019-2020 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { FabricConnectionState } from '../fabric.api';
import { MessageType, ORG_ID, ORGS } from '../bus.api';
import { BrokerConnector } from '../bridge/broker-connector';
import { GeneralUtil } from '../util/util';
import { RequestHeaderConsts, Stores } from './fabric.model';
import { APIRequest } from '../core/model/request.model';
import { APIResponse } from '../core/model/response.model';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
export const HEADERS_STORE = 'transport-headers-store';
export const GLOBAL_HEADERS = 'global-headers';
export const GLOBAL_HEADERS_UPDATE = 'update';
export const DEFAULT_ACCESS_TOKEN_KEY = 'accessToken';
export class FabricApiImpl {
    constructor(bus) {
        this.bus = bus;
        this.accessTokenSessionStorageKey = RequestHeaderConsts.CSP_AUTH_TOKEN;
        this.xsrfTokenEnabled = false;
        this.xsrfTokenStoreKey = `${RequestHeaderConsts.CUSTOM_HEADER_PREFIX}${RequestHeaderConsts.XSRF_TOKEN}`;
        this._accessTokenHeaderKey = DEFAULT_ACCESS_TOKEN_KEY;
        this._sendAccessTokenDuringHandshake = false;
        this.bus = bus;
        this.headersStore = this.bus.stores.createStore(HEADERS_STORE);
        this.connectedMap = new Map();
        this.sessionIdMap = new Map();
        this.connectHandlerMap = new Map();
        this.disconnectHandlerMap = new Map();
        this.connectionStoreMap = new Map();
    }
    getDefaultConnectionString() {
        if (this.connectionStoreMap.size === 1) {
            return this.connectionStoreMap.keys().next().value.toString();
        }
        else if (this.connectionStoreMap.size === 0) {
            this.bus.logger.error('Could not determine the default connection string because fabric.connect() likely ' +
                'was not called first. You can either call fabric.connect() first or optionally provide ' +
                'a connection string, if you know it, to the method you were calling as an argument.', 'FabricApi');
        }
        else {
            this.bus.logger.error('Could not determine the default connection string. ' +
                'There is more than one active connection. Please provide the connection string manually', 'FabricApi');
        }
        return '';
    }
    getConnectionStateStore(connString) {
        connString = connString || this.getDefaultConnectionString();
        let store;
        if (!this.connectionStoreMap.has(connString)) {
            store = this.bus.stores.createStore(Stores.FabricConnection);
            this.connectionStoreMap.set(connString, store);
        }
        else {
            store = this.connectionStoreMap.get(connString);
        }
        return store;
    }
    isConnected(connString) {
        connString = connString || this.getDefaultConnectionString();
        return this.connectedMap.has(connString) && this.connectedMap.get(connString);
    }
    whenConnectionStateChanges(connString) {
        connString = connString || this.getDefaultConnectionString();
        if (!this.connectionStoreMap.has(connString)) {
            this.connectionStoreMap.set(connString, this.bus.stores.createStore(Stores.FabricConnection));
        }
        // immediately fire the current state of the FabricConnectionState store so it can be aware of changes to
        // fabric connection state that occurred before whenConnectionStateChanges method was called. note this logic
        // is scheduled as a macrotask so it is guaranteed to fire after the store has been subscribed.
        const currentState = this.bus.stores.getStore(Stores.FabricConnection).get(connString);
        if (currentState !== undefined) {
            this.bus.api.tickEventLoop(() => {
                this.bus.stores.getStore(Stores.FabricConnection).put(connString, currentState, currentState);
            });
        }
        return this.connectionStoreMap.get(connString)
            .onChange(connString, FabricConnectionState.Disconnected, FabricConnectionState.Connected, FabricConnectionState.Failed);
    }
    connect(connectHandler, disconnectHandler, host, port, endpoint = '/fabric', useSSL = false, topicLocation = '/topic', queueLocation = '/queue', numRelays = 1, autoReconnect = true) {
        // create unique identifier for the session.
        const connString = GeneralUtil.getFabricConnectionString(host, port, endpoint);
        if (!this.connectedMap.get(connString)) {
            // create reference to connection store.
            if (!this.connectionStoreMap.get(connString)) {
                this.connectionStoreMap.set(connString, this.bus.stores.createStore(Stores.FabricConnection));
            }
            this.createWindowConnectionEventListeners(connString);
            this.connectHandlerMap.set(connString, connectHandler);
            this.disconnectHandlerMap.set(connString, disconnectHandler);
            const connectedHandler = (sessionId) => {
                this.setConnected(connString);
                this.sessionIdMap.set(connString, sessionId);
                this.connectHandlerMap.get(connString)(connString);
                // listen for disconnect from broker connector.
                // this needs to be refactored in a cleaner way.
                if (!this.fabricDisconnectHandler) {
                    this.fabricDisconnectHandler = this.bus.listenStream(`transport-services::broker.connector-status`);
                    this.fabricDisconnectHandler.handle((busCommand) => {
                        switch (busCommand.command) {
                            case 'DISCONNECTED':
                                this.setDisconnected(connString);
                                if (this.disconnectHandlerMap.get(connString)) {
                                    this.disconnectHandlerMap.get(connString)();
                                }
                                break;
                        }
                    });
                }
            };
            // ensure this is non-blocking
            this.bus.api.tickEventLoop(() => {
                this.bus.connectBridge(connectedHandler, endpoint, topicLocation, queueLocation, numRelays, host, port, '/pub', null, null, useSSL, autoReconnect);
            });
        }
        else {
            // already connected, handle connection state.
            if (this.connectHandlerMap.get(connString)) {
                this.connectHandlerMap.get(connString)(this.sessionIdMap.get(connString));
            }
        }
    }
    disconnect(connString) {
        connString = connString || this.getDefaultConnectionString();
        BrokerConnector.fireDisconnectCommand(this.bus, this.sessionIdMap.get(connString));
        this.setDisconnected(connString);
    }
    setFabricCurrentOrgId(orgId) {
        this.bus.stores.createStore(ORGS).put(ORG_ID, orgId, null);
    }
    createWindowConnectionEventListeners(connString) {
        // if the window object is available, lets listen for events from developer tools to aid testing.
        if (window) {
            window.addEventListener('offline', () => {
                this.setDisconnected(connString);
                if (this.disconnectHandlerMap.has(connString)) {
                    this.disconnectHandlerMap.get(connString)();
                }
            });
            window.addEventListener('online', () => {
                this.setConnected(connString);
                if (this.connectHandlerMap.has(connString)) {
                    this.connectHandlerMap.get(connString)(this.sessionIdMap.get(connString));
                }
            });
        }
    }
    setConnected(connString) {
        connString = connString || this.getDefaultConnectionString();
        this.connectedMap.set(connString, true);
    }
    setDisconnected(connString) {
        connString = connString || this.getDefaultConnectionString();
        this.connectedMap.set(connString, false);
        this.connectionStoreMap.get(connString).put(connString, FabricConnectionState.Disconnected, FabricConnectionState.Disconnected);
    }
    generateFabricRequest(requestCommand, payload, headers) {
        if (!payload) {
            payload = '';
        }
        if (this.bus.fabric.isXsrfTokenEnabled()) {
            headers = Object.assign(Object.assign({}, headers), { [this.bus.fabric.getXsrfTokenStoreKey()]: this.bus.fabric.getXsrfToken() });
        }
        return new APIRequest(requestCommand, payload, GeneralUtil.genUUID(), 1, headers);
    }
    generateFabricResponse(id, payload, error = false, errorCode = 0, errorMessage = '', version = 1) {
        if (!payload) {
            payload = '';
        }
        return new APIResponse(payload, error, errorCode, errorMessage, id, version);
    }
    getFabricVersion(connString) {
        connString = connString || this.getDefaultConnectionString();
        // open version channel.
        this.bus.markChannelAsGalactic(FabricApiImpl.versionChannel, connString);
        let handler;
        if (this.connectedMap.get(connString)) {
            handler = this.bus.requestOnceWithId(GeneralUtil.genUUID(), FabricApiImpl.versionChannel, this.generateFabricRequest('version', ''));
        }
        else {
            handler = null;
        }
        if (handler) {
            return handler.getObservable(MessageType.MessageTypeResponse).pipe(map((resp) => {
                return resp.payload;
            }));
        }
        else {
            return of('Version unavailable, not connected to fabric');
        }
    }
    setAccessTokenSessionStorageKey(key) {
        this.bus.logger.debug(`Setting access token session storage key to: ${key}`, 'FabricApi');
        this.accessTokenSessionStorageKey = key;
    }
    getAccessTokenSessionStorageKey() {
        return this.accessTokenSessionStorageKey;
    }
    get getAccessTokenFunction() {
        return this._getAccessTokenFunction;
    }
    set getAccessTokenFunction(value) {
        this._getAccessTokenFunction = value;
    }
    get accessTokenHeaderKey() {
        return this._accessTokenHeaderKey;
    }
    set accessTokenHeaderKey(value) {
        this._accessTokenHeaderKey = value;
    }
    getAccessToken() {
        let token;
        if (this.getAccessTokenFunction) {
            token = this.getAccessTokenFunction();
        }
        else {
            const key = this.getAccessTokenSessionStorageKey();
            token = sessionStorage.getItem(key);
        }
        return token || '';
    }
    get sendAccessTokenDuringHandshake() {
        return this._sendAccessTokenDuringHandshake;
    }
    set sendAccessTokenDuringHandshake(value) {
        this._sendAccessTokenDuringHandshake = value;
    }
    get protocols() {
        return this._protocols;
    }
    set protocols(value) {
        this._protocols = value;
    }
    setXsrfToken(token) {
        this.bus.stores.createStore(Stores.XsrfToken).put(this.getXsrfTokenStoreKey(), token, 'xsrftokenSet');
    }
    getXsrfToken() {
        // return the token if found in the cookie
        const token = GeneralUtil.getCookie(this.getXsrfTokenStoreKey().replace(RequestHeaderConsts.CUSTOM_HEADER_PREFIX, ''));
        if (token !== null) {
            return token;
        }
        return this.bus.stores.createStore(Stores.XsrfToken).get(this.getXsrfTokenStoreKey()) || '';
    }
    setXsrfTokenStoreKey(key) {
        this.bus.logger.debug(`Setting XSRF token store key to: ${key}`, 'FabricApi');
        this.xsrfTokenStoreKey = key;
    }
    getXsrfTokenStoreKey() {
        return this.xsrfTokenStoreKey;
    }
    isXsrfTokenEnabled() {
        return this.xsrfTokenEnabled;
    }
    setXsrfTokenEnabled(value) {
        if (value) {
            // construct or get a xsrf token store
            this.bus.stores.createStore(Stores.XsrfToken);
        }
        this.xsrfTokenEnabled = value;
    }
    useFabricRestService() {
        this.bus.logger.info('Switching to Fabric based RestService, all REST calls will be routed via fabric', 'FabricApi');
        this.bus.markChannelAsGalactic('fabric-rest');
    }
    useLocalRestService() {
        this.bus.logger.info('Switching local RestService, all REST calls will be routed via browser', 'FabricApi');
        this.bus.markChannelAsLocal('fabric-rest');
    }
    getGlobalHttpHeaders() {
        return this.headersStore.get(GLOBAL_HEADERS);
    }
}
FabricApiImpl.versionChannel = 'fabric-version';
//# sourceMappingURL=fabric.js.map