import { FabricApi, FabricConnectionState } from '../fabric.api';
import { EventBus, MessageFunction } from '../bus.api';
import { UUID } from '../bus/store/store.model';
import { BusStore, StoreStream } from '../store.api';
import { APIRequest } from '../core/model/request.model';
import { APIResponse } from '../core/model/response.model';
import { Observable } from 'rxjs';
export declare const HEADERS_STORE = "transport-headers-store";
export declare const GLOBAL_HEADERS = "global-headers";
export declare const GLOBAL_HEADERS_UPDATE = "update";
export declare const DEFAULT_ACCESS_TOKEN_KEY = "accessToken";
export declare class FabricApiImpl implements FabricApi {
    private readonly bus;
    static readonly versionChannel = "fabric-version";
    private connectedMap;
    private sessionIdMap;
    private connectHandlerMap;
    private disconnectHandlerMap;
    private connectionStoreMap;
    private fabricDisconnectHandler;
    private headersStore;
    private accessTokenSessionStorageKey;
    private xsrfTokenEnabled;
    private xsrfTokenStoreKey;
    constructor(bus: EventBus);
    getDefaultConnectionString(): string;
    getConnectionStateStore(connString?: string): BusStore<FabricConnectionState>;
    isConnected(connString?: string): boolean;
    whenConnectionStateChanges(connString?: string): StoreStream<FabricConnectionState>;
    connect(connectHandler: MessageFunction<string>, disconnectHandler: Function, host?: string, port?: number, endpoint?: string, useSSL?: boolean, topicLocation?: string, queueLocation?: string, numRelays?: number, autoReconnect?: boolean): void;
    disconnect(connString?: string): void;
    setFabricCurrentOrgId(orgId: UUID): void;
    private createWindowConnectionEventListeners;
    private setConnected;
    private setDisconnected;
    generateFabricRequest<T>(requestCommand: string, payload?: T, headers?: {
        [key: string]: any;
    }): APIRequest<T>;
    generateFabricResponse<T>(id: UUID, payload: T, error?: boolean, errorCode?: number, errorMessage?: string, version?: number): APIResponse<T>;
    getFabricVersion(connString?: string): Observable<string>;
    setAccessTokenSessionStorageKey(key: string): void;
    getAccessTokenSessionStorageKey(): string;
    private _getAccessTokenFunction;
    get getAccessTokenFunction(): () => string;
    set getAccessTokenFunction(value: () => string);
    private _accessTokenHeaderKey;
    get accessTokenHeaderKey(): string;
    set accessTokenHeaderKey(value: string);
    getAccessToken(): string;
    private _sendAccessTokenDuringHandshake;
    get sendAccessTokenDuringHandshake(): boolean;
    set sendAccessTokenDuringHandshake(value: boolean);
    private _protocols;
    get protocols(): Array<string>;
    set protocols(value: Array<string>);
    setXsrfToken(token: string): void;
    getXsrfToken(): string;
    setXsrfTokenStoreKey(key: string): void;
    getXsrfTokenStoreKey(): string;
    isXsrfTokenEnabled(): boolean;
    setXsrfTokenEnabled(value: boolean): void;
    useFabricRestService(): void;
    useLocalRestService(): void;
    getGlobalHttpHeaders(): any;
}
