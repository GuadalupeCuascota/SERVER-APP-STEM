/*
 * Copyright 2017-2020 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { MonitorObject, MonitorType } from './model/monitor.model';
import { Message, MessageHandlerConfig } from './model/message.model';
import { BrokerConnectorChannel, StompConfig } from '../bridge/stomp.model';
import { StompClient } from '../bridge/stomp.client';
import { StompParser } from '../bridge/stomp.parser';
import { EventBus, TransactionType } from '../bus.api';
import { EventBusLowLevelApiImpl } from './bus.lowlevel';
import { Logger } from '../log/logger.service';
import { LogLevel } from '../log/logger.model';
import { StoreManager } from './store/store.manager';
import { BusTransactionImpl } from './transaction';
import { BrokerConnector } from '../bridge/broker-connector';
import { GeneralUtil } from '../util/util';
import { MessageProxy } from '../proxy/message.proxy';
import { FabricApiImpl } from '../fabric/fabric';
export class TransportEventBus extends EventBus {
    constructor(logLevel = LogLevel.Off, disableBootMessage = true, darkTheme = false) {
        super();
        this.windowRef = window;
        this.devModeEnabled = false;
        this.internalChannelMap = new Map();
        // logging
        this.log = new Logger();
        // enable dark theme on logging.
        if (darkTheme) {
            this.log.useDarkTheme(true);
        }
        // Low Level API.
        this.api = new EventBusLowLevelApiImpl(this, this.internalChannelMap, this.log);
        // Store API
        this.stores = new StoreManager(this);
        this.brokerConnector = new BrokerConnector(this.log);
        // wire up singleton to the window object under a custom namespace.
        this.windowRef.AppEventBus = this;
        this.windowRef.AppBrokerConnector = this.brokerConnector;
        this.windowRef.AppBrokerConnector.init(this);
        this.windowRef.window.AppSyslog = this.log;
        this.windowRef.AppStoreManager = this.stores;
        if (!disableBootMessage) {
            this.log.setStylingVisble(true);
            this.log.info(`ðŸŒˆ VMware Transport v${EventBus.version} Initialized with Id: ${EventBus.id}, Hi!`, 'EventBus');
        }
        // set up logging.
        this.log.logLevel = logLevel;
        this.api.setLogLevel(logLevel);
        this.fabric = new FabricApiImpl(this);
        // say hi to magnum.
        // this.easterEgg();
    }
    /**
     * Destroy the bus completely.
     */
    static destroy() {
        this.instance.destroy();
        this.instance = null;
    }
    static getInstance() {
        return TransportEventBus.boot();
    }
    /**
     * Boot and create a singleton EventBus instance with default options
     * @returns {EventBus} the bus.
     */
    static boot() {
        return this.instance || (this.instance = new this());
    }
    /**
     * Boot and create a singleton EventBus instance with custom options for logging level and boot message
     * @param {LogLevel} logLevel log level to set
     * @param {boolean} disableBootMessage set to true to turn off the boot message.
     * @param {boolean} darkTheme enable dark theme logging (defaults to false)
     * @returns {EventBus} the bus
     */
    static bootWithOptions(logLevel, disableBootMessage, darkTheme = false) {
        return this.instance || (this.instance = new this(logLevel, disableBootMessage, darkTheme));
    }
    /**
     * Reboot the bus, critical for tests, reboot destroys the singleton and re-creates it.
     * @param {LogLevel} logLevel  log level to set
     * @param {boolean} disableBootMessage set true to turn off the boot message.
     * @returns {EventBus} the newly rebooted bus
     */
    static rebootWithOptions(logLevel, disableBootMessage) {
        this.instance = new this(logLevel, disableBootMessage, false);
        return this.instance;
    }
    /**
     * Reboot the bus, critical for tests, reboot destroys the singleton and re-creates it.
     * @returns {EventBus} the newly rebooted event bus.
     */
    static reboot() {
        //EventBus.id = EventBus.rebuildId(); // reset the ID attached to the abstract class.
        //this.instance = null;
        //delete this.instance;
        return (this.instance = new this());
    }
    get logger() {
        return this.log;
    }
    getName() {
        return 'EventBus';
    }
    setNgZoneRef(ngZoneRef) {
        this.zoneRef = ngZoneRef;
        this.api.setUpNgViewRefreshScheduler();
    }
    destroy() {
        var _a;
        // unsubscribe from Angular change detection scheduler
        (_a = this.api.ngViewRefreshSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        // other future cleanup code goes in here
    }
    enableDevMode() {
        this.devModeEnabled = true;
        this.log.warn('Dev Mode Enabled on Event Bus, This should never be enabled in production');
    }
    enableMessageProxy(config) {
        this.messageProxy = new MessageProxy(this);
        this.proxyControl = this.messageProxy.enableProxy(config);
        return this.proxyControl;
    }
    connectBridge(readyHandler, endpoint, topicLocation, queueLocation, numBrokerRelays = 1, host, port, applicationDestinationPrefix, user, pass, useSSL, autoReconnect = true, advancedConfig) {
        const config = StompConfig.generate(endpoint, host, port, useSSL, user, pass, applicationDestinationPrefix);
        config.topicLocation = topicLocation;
        config.queueLocation = queueLocation;
        config.brokerConnectCount = numBrokerRelays;
        config.autoReconnect = autoReconnect;
        config.getAccessTokenFunction = this.fabric.getAccessToken.bind(this.fabric);
        config.accessTokenHeaderKey = this.fabric.accessTokenHeaderKey;
        config.sendAccessTokenDuringHandshake = this.fabric.sendAccessTokenDuringHandshake;
        config.protocols = this.fabric.protocols ? this.fabric.protocols.slice() : undefined;
        if (advancedConfig) {
            config.heartbeatIn = advancedConfig.heartbeatIncomingInterval;
            config.heartbeatOut = advancedConfig.heartbeatOutgoingInterval;
            config.startIntervalFunction = advancedConfig.startIntervalFunction;
        }
        // create fake socket instead of a real socket, should never be used in production.
        if (this.devModeEnabled) {
            config.testMode = true;
        }
        const handler = this.requestStreamWithId(GeneralUtil.getFabricConnectionString(config.host, config.port, config.endpoint), BrokerConnectorChannel.connection, StompParser.generateStompBusCommand(StompClient.STOMP_CONNECT, '', '', config));
        handler.handle((command) => {
            if (command.command === StompClient.STOMP_CONNECTED) {
                readyHandler(command.session);
                handler.close();
            }
            else {
                this.api.logger()
                    .info('connection handler received command message: ' + command.command, this.getName());
            }
        });
        return handler;
    }
    listenGalacticStream(cname, name = this.getName(), galacticConfig) {
        if (!this.internalChannelMap.has(cname)) {
            this.api.getGalacticChannel(cname, galacticConfig, name, false); // create a public galactic channel by default;
        }
        return this.listenStream(cname, name);
    }
    isGalacticChannel(cname) {
        if (this.internalChannelMap.has(cname)) {
            return this.internalChannelMap.get(cname).galactic;
        }
        return false;
    }
    closeGalacticChannel(cname, from, brokerIdentity) {
        this.api.getMonitorStream().send(new Message().request(new MonitorObject().build(MonitorType.MonitorGalacticUnsubscribe, cname, from, brokerIdentity)));
    }
    sendGalacticMessage(cname, payload, from) {
        this.api.getMonitorStream().send(new Message().request(new MonitorObject().build(MonitorType.MonitorGalacticData, cname, from, payload)));
    }
    sendRequestMessage(cname, payload, name = this.getName()) {
        this.api.send(cname, new Message().request(payload), name);
    }
    sendRequestMessageWithId(cname, payload, id, from, proxyBroadcast = false) {
        this.api.send(cname, new Message(id, 1, proxyBroadcast).request(payload), from);
    }
    sendRequestMessageWithIdAndVersion(cname, payload, id, version, from, proxyBroadcast = false) {
        this.api.send(cname, new Message(id, version, proxyBroadcast).request(payload), from);
    }
    sendResponseMessage(cname, payload, name = this.getName()) {
        this.api.send(cname, new Message().response(payload), name);
        return true;
    }
    sendResponseMessageWithId(cname, payload, id, from, proxyBroadcast = false) {
        this.api.send(cname, new Message(id, 1, proxyBroadcast).response(payload), from);
    }
    sendResponseMessageWithIdAndVersion(cname, payload, id, version, from, proxyBroadcast = false) {
        this.api.send(cname, new Message(id, version, proxyBroadcast).response(payload), from);
    }
    sendErrorMessageWithId(cname, payload, id, from, proxyBroadcast) {
        this.api.send(cname, new Message(id, 1, proxyBroadcast).error(payload), from);
    }
    sendErrorMessageWithIdAndVersion(cname, payload, id, version, from, proxyBroadcast) {
        this.api.send(cname, new Message(id, version, proxyBroadcast).error(payload), from);
    }
    sendErrorMessage(cname, payload, name = this.getName(), proxyBroadcast = false) {
        this.api.send(cname, new Message(GeneralUtil.genUUID(), 1, proxyBroadcast).error(payload), name);
    }
    respondOnce(sendChannel, returnChannel, name = this.getName()) {
        return this.api.respond(new MessageHandlerConfig(sendChannel, null, true, returnChannel), name);
    }
    respondStream(sendChannel, returnChannel, name = this.getName()) {
        return this.api.respond(new MessageHandlerConfig(sendChannel, null, false, returnChannel), name);
    }
    requestStream(sendChannel, requestPayload, returnChannel, name = this.getName()) {
        return this.api.request(new MessageHandlerConfig(sendChannel, requestPayload, false, returnChannel), name);
    }
    requestStreamWithId(uuid, sendChannel, requestPayload, returnChannel, name = this.getName()) {
        return this.api.request(new MessageHandlerConfig(sendChannel, requestPayload, false, returnChannel), name, uuid);
    }
    requestOnce(sendChannel, requestPayload, returnChannel, name = this.getName()) {
        return this.api.request(new MessageHandlerConfig(sendChannel, requestPayload, true, returnChannel), name);
    }
    requestOnceWithId(uuid, sendChannel, requestPayload, returnChannel, from) {
        return this.api.request(new MessageHandlerConfig(sendChannel, requestPayload, true, returnChannel), from, uuid);
    }
    listenOnce(channel, name = this.getName(), id) {
        return this.api.listen(new MessageHandlerConfig(channel, null, true, channel), false, name);
    }
    listenStream(channel, name = this.getName(), id) {
        return this.api.listen(new MessageHandlerConfig(channel, null, false, channel), false, name, id);
    }
    listenRequestOnce(channel, name = this.getName(), id) {
        return this.api.listen(new MessageHandlerConfig(channel, null, true, channel), true, name, id);
    }
    listenRequestStream(channel, name = this.getName(), id) {
        return this.api.listen(new MessageHandlerConfig(channel, null, false, channel), true, name, id);
    }
    closeChannel(cname, from) {
        return this.api.close(cname, from);
    }
    createTransaction(type = TransactionType.ASYNC, name = 'Transaction' + GeneralUtil.genUUID()) {
        return new BusTransactionImpl(this, this.log, type, name);
    }
    easterEgg() {
        const chan = this.api.getRequestChannel('__maglingtonpuddles__', this.getName(), true);
        chan.subscribe(() => {
            const msg = 'Maggie wags his little nubby tail at you, ' +
                'as he sits under his little yellow boat on the beach';
            this.sendResponseMessage('__maglingtonpuddles__', msg);
        });
    }
    markChannelsAsGalactic(channelNames) {
        for (const channelName of channelNames) {
            this.markChannelAsGalactic(channelName);
        }
    }
    markChannelAsGalactic(channelName, brokerIdentity, isPrivate) {
        const channel = this.api.getChannelObject(channelName);
        channel.setGalactic();
        if (isPrivate === true) {
            channel.setPrivate();
        }
        else {
            channel.setPublic();
        }
        this.api.getMonitorStream().send(new Message().request(new MonitorObject().build(MonitorType.MonitorNewGalacticChannel, channelName, this.getName(), { isPrivate: channel.isPrivate, brokerIdentity: brokerIdentity })));
    }
    markChannelsAsLocal(channelNames) {
        for (const channelName of channelNames) {
            this.markChannelAsLocal(channelName);
        }
    }
    markChannelAsLocal(channelName, brokerIdentity) {
        const channel = this.api.getChannelObject(channelName);
        channel.setLocal();
        this.api.getMonitorStream().send(new Message().request(new MonitorObject().build(MonitorType.MonitorGalacticUnsubscribe, channelName, this.getName(), { isPrivate: channel.isPrivate, brokerIdentity })));
    }
}
//# sourceMappingURL=bus.js.map