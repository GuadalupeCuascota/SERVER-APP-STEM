/*
 * Copyright 2017-2020 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { MessageType } from '../bus.api';
import { Channel } from './model/channel.model';
import { Message, MessageHandlerConfig } from './model/message.model';
import { Subject, merge } from 'rxjs';
import { debounceTime, filter, map } from 'rxjs/operators';
import { LogLevel } from '../log/logger.model';
import { MonitorChannel, MonitorObject, MonitorType } from './model/monitor.model';
import { LogUtil } from '../log/util';
import { GeneralUtil } from '../util/util';
// interval to debounce the scheduling of angular change detection with
const NGZONE_TRIGGER_DEBOUNCE_THRESHOLD = 10;
export class EventBusLowLevelApiImpl {
    constructor(eventBusRef, channelMap, logger) {
        this.eventBusRef = eventBusRef;
        this.monitorChannel = MonitorChannel.stream;
        this.internalChannelMap = channelMap;
        this.id = GeneralUtil.genUUID();
        // create monitor stream.
        this.monitorStream = new Channel(this.monitorChannel);
        this.internalChannelMap.set(this.monitorChannel, this.monitorStream);
        // set up logging.
        this.log = logger;
        // disable monitor dump by default.
        this.enableMonitorDump(false);
        this.monitorBus();
        this.channelMap = this.internalChannelMap;
        this.loggerInstance = this.log;
    }
    getId() {
        return this.id;
    }
    ngZone() {
        return this._ngZone;
    }
    getChannel(cname, from, noRefCount = false) {
        return this.getChannelObject(cname, from, noRefCount)
            .stream
            .pipe(map((msg) => {
            if (msg.payload && msg.payload.hasOwnProperty('sendChannel')) {
                msg.payload = msg.payload.body;
            }
            return msg;
        }));
    }
    getChannelObject(name, from, noRefCount = false, broadcast = true) {
        let channel;
        let symbol;
        const monitorNewReference = () => {
            const observerId = channel.createObserver();
            let mo = new MonitorObject().build(MonitorType.MonitorObserverJoinedChannel, name, from, { count: channel.refCount, id: observerId, from: from });
            this.monitorStream.send(new Message().request(mo));
        };
        const newChannelCreated = () => {
            let mo = new MonitorObject().build(MonitorType.MonitorNewChannel, name, from, '');
            this.monitorStream.send(new Message().request(mo));
        };
        let newChannel = false;
        if (this.internalChannelMap.has(name)) {
            channel = this.internalChannelMap.get(name);
        }
        else {
            channel = new Channel(name);
            this.internalChannelMap.set(name, channel);
            newChannel = true;
        }
        if (!noRefCount) {
            channel.increment();
        }
        if (newChannel && broadcast) {
            newChannelCreated();
        }
        if (!noRefCount && broadcast) {
            monitorNewReference();
        }
        return channel;
    }
    getRequestChannel(name, from, noRefCount = false) {
        return this.getChannel(name, from, noRefCount)
            .pipe(filter((message) => {
            return (message.isRequest());
        }));
    }
    getResponseChannel(cname, from, noRefCount = false) {
        return this.getChannel(cname, from, noRefCount)
            .pipe(filter((message) => {
            return (message.isResponse());
        }));
    }
    getErrorChannel(cname, from, noRefCount = false) {
        return this.getChannel(cname, from, noRefCount)
            .pipe(filter((message) => {
            return (message.isError());
        }));
    }
    getGalacticChannel(cname, galacticConfig, from, noRefCount = false) {
        this.getMonitorStream().send(new Message().request(new MonitorObject().build(MonitorType.MonitorNewGalacticChannel, cname, from, galacticConfig)));
        return this.getChannelObject(cname, from, noRefCount)
            .setGalactic().stream
            .pipe(map((msg) => {
            // just an FYI -  I hate this... I made a bad choice and I will fix it!
            if (msg.payload.hasOwnProperty('sendChannel')) {
                msg.payload = msg.payload.body;
            }
            return msg;
        }));
    }
    sendRequest(cname, payload, name) {
        const mh = new MessageHandlerConfig(cname, payload, true, cname);
        this.send(mh.sendChannel, new Message().request(mh), name);
    }
    sendResponse(cname, payload, name) {
        const mh = new MessageHandlerConfig(cname, payload, true, cname);
        this.send(mh.sendChannel, new Message().response(mh), name);
    }
    complete(cname, from) {
        if (!this.internalChannelMap.has(cname)) {
            return false;
        }
        this.monitorStream.send(new Message().request(new MonitorObject().build(MonitorType.MonitorCompleteChannel, cname, from)));
        const channel = this.internalChannelMap.get(cname);
        channel.complete();
        this.destroy(channel, from);
        return true;
    }
    close(cname, from, observerId = 'none') {
        if (!this.internalChannelMap.has(cname)) {
            return false;
        }
        let channel = this.internalChannelMap.get(cname);
        channel.decrement();
        let mo = new MonitorObject().build(MonitorType.MonitorObserverLeftChannel, cname, from, { count: channel.refCount, from: from, id: observerId });
        this.monitorStream.send(new Message().request(mo));
        if (channel.refCount === 0) {
            mo = new MonitorObject().build(MonitorType.MonitorCloseChannel, cname, from, channel.refCount);
            this.monitorStream.send(new Message().request(mo));
            this.destroy(channel, from);
            return true;
        }
    }
    countListeners() {
        let count = 0;
        this.channelMap.forEach((channel) => {
            //console.log('channel open: ' + channel.name + ' - ' + channel.refCount);
            count += channel.refCount;
        });
        //console.log('----\n\n');
        return count;
    }
    destroyAllChannels() {
        this.channelMap.forEach((channel, name) => {
            this.destroy(channel, name);
        });
    }
    refCount(cname) {
        if (!this.internalChannelMap.has(cname)) {
            return -1;
        }
        return this.internalChannelMap.get(cname).refCount;
    }
    increment(cname) {
        return this.channelMap.get(cname).increment();
    }
    getMonitor() {
        return this.monitorStream.stream;
    }
    getMonitorStream() {
        return this.monitorStream;
    }
    isLoggingEnabled() {
        return this.dumpMonitor;
    }
    enableMonitorDump(flag) {
        this.dumpMonitor = flag;
    }
    logger() {
        return this.log;
    }
    messageLog(msg, from) {
        this.log.info(msg, from);
    }
    suppressLog(set) {
        this.log.suppress(set);
    }
    silenceLog(set) {
        this.log.silent(set);
    }
    setLogLevel(logLevel) {
        this.log.logLevel = logLevel;
    }
    send(cname, message, from) {
        message.sender = from; // make sure we know where this message came from.
        const channelFound = this.internalChannelMap.has(cname);
        let mo = new MonitorObject().build(channelFound ? MonitorType.MonitorData : MonitorType.MonitorDropped, cname, from, message);
        if (!channelFound) {
            this.monitorStream.send(new Message().request(mo));
            return false;
        }
        if (this.eventBusRef.zoneRef) {
            this.eventBusRef.zoneRef.runOutsideAngular(() => {
                var _a;
                this.internalChannelMap.get(cname).send(message);
                this.monitorStream.send(new Message().request(mo));
                (_a = this.ngViewRefreshSubject) === null || _a === void 0 ? void 0 : _a.next();
            });
        }
        else {
            this.monitorStream.send(new Message().request(mo));
            this.internalChannelMap.get(cname).send(message);
        }
        return true;
    }
    error(cname, err) {
        if (!this.internalChannelMap.has(cname)) {
            return false;
        }
        const mo = new MonitorObject().build(MonitorType.MonitorError, cname, err);
        this.monitorStream.send(new Message().error(mo));
        this.internalChannelMap.get(cname)
            .error(err);
        return true;
    }
    tickEventLoop(func, delay = 0) {
        return setTimeout(func, delay);
    }
    request(handlerConfig, name, id) {
        const handler = this.createMessageHandler(handlerConfig, false, name, id);
        this.send(handlerConfig.sendChannel, new Message(id).request(handlerConfig), name);
        return handler;
    }
    respond(handlerConfig, name) {
        return this.createMessageResponder(handlerConfig, name);
    }
    listen(handlerConfig, requestStream, name, id) {
        return this.createMessageHandler(handlerConfig, requestStream, name, id);
    }
    setUpNgViewRefreshScheduler() {
        var _a;
        // kill any existing subscription
        (_a = this.ngViewRefreshSubscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        // grab and store handle of angular zone
        this._ngZone = this.eventBusRef.zoneRef;
        // create a Subject that triggers Angular change detection when a new message arrives. to prevent
        // suffocating CPU resource from too many cycles, debounce the incoming messages by NGZONE_TRIGGER_DEBOUNCE_THRESHOLD milliseconds.
        this.ngViewRefreshSubject = new Subject();
        this.ngViewRefreshSubscription = this.ngViewRefreshSubject
            .pipe(debounceTime(NGZONE_TRIGGER_DEBOUNCE_THRESHOLD))
            .subscribe(() => this.eventBusRef.zoneRef.run(() => { }));
    }
    /**
     * PRIVATE METHODS.
     */
    /**
     * Create a message Responder.
     *
     * @param {MessageHandlerConfig} handlerConfig
     * @param {string} name
     * @param schema
     * @returns {MessageResponder<T, E>}
     */
    createMessageResponder(handlerConfig, name) {
        let sub;
        const errorChannel = this.getErrorChannel(handlerConfig.sendChannel, name, true);
        const requestChannel = this.getRequestChannel(handlerConfig.sendChannel, name);
        let closed = false;
        const chanObject = this.getChannelObject(handlerConfig.returnChannel, name, true);
        const subscriberId = chanObject.createSubscriber();
        const latestObserver = chanObject.latestObserver;
        const killSubscription = () => {
            sub.unsubscribe();
            this.sendUnsubscribedMonitorMessage(subscriberId, chanObject.name, name);
            chanObject.removeSubscriber(subscriberId);
            this.close(handlerConfig.sendChannel, name, latestObserver);
            sub = null;
            closed = true;
        };
        return {
            generate: (generateSuccessResponse, generateErrorResponse) => {
                this.sendSubscribedMonitorMessage(subscriberId, chanObject.name, name);
                const mergedStreams = merge(errorChannel, requestChannel);
                sub = mergedStreams.subscribe((msg) => {
                    let pl = msg.payload;
                    if (!msg.isError()) {
                        this.tickEventLoop(() => {
                            this.eventBusRef.sendResponseMessageWithIdAndVersion(handlerConfig.returnChannel, generateSuccessResponse(pl, { uuid: msg.id, version: msg.version, from: msg.sender }), msg.id, msg.version, name);
                        });
                    }
                    else {
                        let err;
                        if (generateErrorResponse) {
                            err = generateErrorResponse;
                        }
                        else {
                            err = generateSuccessResponse; // what else should we do here?
                        }
                        this.tickEventLoop(() => {
                            this.eventBusRef.sendErrorMessage(handlerConfig.returnChannel, err(pl), name);
                        });
                    }
                    if (handlerConfig.singleResponse) {
                        killSubscription();
                    }
                }, (errorData) => {
                    this.log.error('responder caught error, discarding.', name);
                    if (sub) {
                        killSubscription();
                    }
                });
                return sub;
            },
            tick: (payload) => {
                if (!closed) {
                    this.sendResponse(handlerConfig.returnChannel, payload);
                }
            },
            close: () => {
                if (!handlerConfig.singleResponse) {
                    sub.unsubscribe();
                    // return refcount
                    this.close(handlerConfig.sendChannel, name, latestObserver);
                    this.sendUnsubscribedMonitorMessage(subscriberId, chanObject.name, name);
                    closed = true;
                    sub = null;
                }
                return true;
            },
            isClosed() {
                return closed;
            },
            getObservable() {
                const chan = merge(requestChannel, errorChannel);
                return chan.pipe(map((msg) => {
                    let pl = msg.payload;
                    if (msg.isError()) {
                        throw new Error(pl);
                    }
                    else {
                        return pl;
                    }
                }));
            }
        };
    }
    sendSubscribedMonitorMessage(uuid, channelName, from) {
        this.monitorStream.send(new Message().request(new MonitorObject().build(MonitorType.MonitorObserverSubscribedChannel, channelName, from, { id: uuid, from: from })));
    }
    sendUnsubscribedMonitorMessage(uuid, channelName, from) {
        this.monitorStream.send(new Message().request(new MonitorObject().build(MonitorType.MonitorObserverUnsubscribedChannel, channelName, from, { id: uuid, from: from })));
    }
    /**
     * Create a message handler.
     * @param {MessageHandlerConfig} handlerConfig
     * @param {boolean} requestStream
     * @param {string} name
     * @returns {MessageHandler<any>}
     */
    createMessageHandler(handlerConfig, requestStream = false, name, messageId) {
        let sub;
        const errorChannel = this.getErrorChannel(handlerConfig.returnChannel, name, true);
        const requestChannel = this.getRequestChannel(handlerConfig.returnChannel, name, true);
        const responseChannel = this.getResponseChannel(handlerConfig.returnChannel, name, true);
        const fullChannel = this.getChannel(handlerConfig.returnChannel, name, false);
        const chanObject = this.getChannelObject(handlerConfig.returnChannel, name, true);
        const subscriberId = chanObject.createSubscriber();
        const latestObserver = chanObject.latestObserver;
        this.sendSubscribedMonitorMessage(subscriberId, chanObject.name, name);
        let closed = false;
        const registeredId = messageId;
        const killSubscription = () => {
            sub.unsubscribe();
            chanObject.removeSubscriber(subscriberId);
            this.sendUnsubscribedMonitorMessage(subscriberId, chanObject.name, name);
            this.close(handlerConfig.returnChannel, name, latestObserver);
            sub = null;
            closed = true;
        };
        return {
            handle: (success, error) => {
                let _chan;
                if (requestStream) {
                    _chan = requestChannel;
                }
                else {
                    _chan = responseChannel;
                }
                const mergedStreams = merge(errorChannel, _chan);
                sub = mergedStreams.subscribe((msg) => {
                    // If you have registered your handler with a message ID, this will check and
                    // and in some more checks to ensure only messages with a matching ID will proceed.
                    // this logic will only kick in if the response (inbound) message has an ID, if no ID is
                    // found on the inbound, then validation is bypassed and the gates open regardless.
                    let validateId = false;
                    let proceedToHandle = true;
                    if (registeredId && msg.id) {
                        validateId = true;
                    }
                    if (validateId && msg.id && registeredId !== msg.id) {
                        proceedToHandle = false;
                    }
                    if (proceedToHandle) {
                        let _pl = msg.payload;
                        if (msg.isError()) {
                            if (error) {
                                error(_pl, { uuid: msg.id, version: msg.version, from: msg.sender });
                            }
                        }
                        else {
                            if (success) {
                                success(_pl, { uuid: msg.id, version: msg.version, from: msg.sender });
                            }
                            else {
                                this.log.error('unable to handle response, no handler function supplied', name);
                            }
                        }
                        if (handlerConfig.singleResponse) {
                            if (sub) {
                                killSubscription();
                            }
                        }
                    }
                    else {
                        this.log.debug('* Dropping Message ' + msg.id
                            + ', handler only online for ' + registeredId, name);
                    }
                }, (errorData) => {
                    if (error) {
                        error(errorData);
                    }
                    else {
                        this.log.error('unable to handle error, no error handler function supplied', name);
                    }
                    if (sub) {
                        killSubscription();
                    }
                });
                return sub;
            },
            tick: (payload) => {
                if (!closed) {
                    this.eventBusRef.sendRequestMessageWithId(handlerConfig.sendChannel, payload, messageId);
                }
            },
            error: (payload) => {
                if (sub && !sub.closed) {
                    this.eventBusRef.sendErrorMessage(handlerConfig.returnChannel, payload);
                }
            },
            close: () => {
                if (!handlerConfig.singleResponse) {
                    if (sub) {
                        killSubscription();
                    }
                    sub = null;
                }
                return true;
            },
            isClosed() {
                return closed;
            },
            getObservable(type) {
                let chan;
                //if (type) {
                switch (type) {
                    case MessageType.MessageTypeResponse:
                        chan = responseChannel;
                        break;
                    case MessageType.MessageTypeError:
                        chan = errorChannel;
                        break;
                    case MessageType.MessageTypeRequest:
                        chan = requestChannel;
                        break;
                    default:
                        chan = fullChannel;
                        break;
                }
                //}
                return chan.pipe(map((msg) => {
                    let pl = msg.payload;
                    if (msg.isError()) {
                        throw new Error(pl);
                    }
                    else {
                        return pl;
                    }
                }));
            }
        };
    }
    /**
     * Destroy a Channel and remove it from our map. If it is not closed, close it first.
     *
     * @param {Channel} channel
     * @param {string} from
     * @returns {boolean}
     */
    destroy(channel, from) {
        this.monitorStream.send(new Message().request(new MonitorObject().build(MonitorType.MonitorDestroyChannel, channel.name, from)));
        this.internalChannelMap.delete(channel.name);
    }
    /**
     * Dump data flowing through the monitor API into the console.
     *
     * @param {MonitorObject} mo
     * @param {string} tag
     */
    dumpData(mo, tag, dropped = false) {
        let message = mo.data;
        this.log.group(LogLevel.Info, tag);
        if (message.type === MessageType.MessageTypeRequest) {
            this.log.info('📤 APIRequest (outbound)', null);
        }
        else {
            if (message.type === MessageType.MessageTypeError) {
                this.log.info('⁉️ ERROR!', null);
            }
            else {
                this.log.info('📥 APIResponse (inbound)', 'message type');
            }
        }
        this.log.info('📤 Channel: ' + mo.channel, null);
        if (dropped) {
            this.log.warn('💩 Message Was Dropped!', null);
        }
        this.log.group(LogLevel.Info, message.type === MessageType.MessageTypeError ? '⚠️ Error Payload' : '📦 Message Payload');
        this.log.info(LogUtil.pretty(message.payload), null);
        this.log.groupEnd(LogLevel.Info);
        this.log.groupEnd(LogLevel.Info);
    }
    /**
     * This is a listener on the monitor channel which dumps message events to the console
     */
    monitorBus() {
        this.getMonitor()
            .subscribe((message) => {
            //if (!message.isError()) {
            if (this.dumpMonitor) {
                let mo = message.payload;
                let type = 'Response';
                let pload = mo.data;
                // bypass easteregg.
                if (mo.channel === '__maglingtonpuddles__') {
                    return;
                }
                switch (mo.type) {
                    case MonitorType.MonitorNewChannel:
                        this.log.info('✨ (channel created)-> ' + mo.channel, mo.from);
                        break;
                    case MonitorType.MonitorNewGalacticChannel:
                        this.log.info('🌌 (galactic channel mapped)-> ' + mo.channel, mo.from);
                        break;
                    case MonitorType.MonitorObserverJoinedChannel:
                        this.log.info('👁 (new observer ' + mo.data.id + ' [' + mo.data.count + '])-> ' +
                            mo.channel, mo.data.from);
                        break;
                    case MonitorType.MonitorObserverSubscribedChannel:
                        this.log.info('📡 (observer subscribed [' + mo.data.id + '])-> '
                            + mo.channel, mo.data.from);
                        break;
                    case MonitorType.MonitorObserverUnsubscribedChannel:
                        this.log.info('💨 (observer un-subscribed [' + mo.data.id + '])-> '
                            + mo.channel, mo.data.from);
                        break;
                    case MonitorType.MonitorObserverLeftChannel:
                        this.log.info('🗑️ (observer closed [' + mo.data.id + '])-> ' +
                            mo.channel, mo.data.from);
                        break;
                    case MonitorType.MonitorCloseChannel:
                        this.log.info('🚫 (channel closed)-> ' + mo.channel, mo.from);
                        break;
                    case MonitorType.MonitorCompleteChannel:
                        this.log.info('🏁 (channel completed)-> ' + mo.channel, mo.from);
                        break;
                    case MonitorType.MonitorDestroyChannel:
                        this.log.info('💣 (channel destroyed)-> ' + mo.channel, mo.from);
                        break;
                    case MonitorType.MonitorData:
                        if (pload.type === MessageType.MessageTypeRequest) {
                            type = 'Request';
                        }
                        if (pload.type === MessageType.MessageTypeError) {
                            type = 'Error';
                        }
                        this.dumpData(mo, '💬 (' + type + ')-> ' + mo.channel + ' [' + mo.from + ']');
                        break;
                    case MonitorType.MonitorDropped:
                        this.dumpData(mo, '💩 (dropped)->  ' + mo.from + ' -> ' + mo.channel, true);
                        break;
                    case MonitorType.MonitorError:
                        this.log.error('(error)-> ' + mo.channel, mo.from);
                        break;
                    default:
                        break;
                }
            }
        });
    }
}
//# sourceMappingURL=bus.lowlevel.js.map