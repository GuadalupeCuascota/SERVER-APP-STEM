import { ChannelBrokerMapping, ChannelName, EventBus, EventBusLowApi, MessageHandler, MessageResponder, NgZoneRef, SentFrom } from '../bus.api';
import { Channel } from './model/channel.model';
import { Message, MessageHandlerConfig } from './model/message.model';
import { Observable, Subject, Subscription } from 'rxjs';
import { Logger } from '../log/logger.service';
import { LogLevel } from '../log/logger.model';
import { UUID } from './store/store.model';
export declare class EventBusLowLevelApiImpl implements EventBusLowApi {
    private eventBusRef;
    readonly channelMap: Map<ChannelName, Channel>;
    private log;
    private monitorChannel;
    private monitorStream;
    private dumpMonitor;
    private internalChannelMap;
    private id;
    private ngViewRefreshSubject?;
    private _ngZone;
    ngViewRefreshSubscription?: Subscription;
    loggerInstance: Logger;
    getId(): UUID;
    ngZone(): NgZoneRef;
    constructor(eventBusRef: EventBus, channelMap: Map<string, Channel>, logger: Logger);
    getChannel(cname: ChannelName, from: SentFrom, noRefCount?: boolean): Observable<Message>;
    getChannelObject(name: ChannelName, from?: SentFrom, noRefCount?: boolean, broadcast?: boolean): Channel;
    getRequestChannel(name: ChannelName, from?: SentFrom, noRefCount?: boolean): Observable<Message>;
    getResponseChannel(cname: ChannelName, from?: SentFrom, noRefCount?: boolean): Observable<Message>;
    getErrorChannel(cname: ChannelName, from?: SentFrom, noRefCount?: boolean): Observable<Message>;
    getGalacticChannel(cname: ChannelName, galacticConfig?: ChannelBrokerMapping, from?: SentFrom, noRefCount?: boolean): Observable<Message>;
    sendRequest(cname: string, payload: any, name?: string): void;
    sendResponse(cname: string, payload: any, name?: string): void;
    complete(cname: ChannelName, from?: SentFrom): boolean;
    close(cname: ChannelName, from?: SentFrom, observerId?: UUID): boolean;
    countListeners(): number;
    destroyAllChannels(): void;
    refCount(cname: ChannelName): number;
    increment(cname: string): number;
    getMonitor(): Subject<Message>;
    getMonitorStream(): Channel;
    isLoggingEnabled(): boolean;
    enableMonitorDump(flag: boolean): void;
    logger(): Logger;
    messageLog(msg: string, from?: SentFrom): void;
    suppressLog(set: boolean): void;
    silenceLog(set: boolean): void;
    setLogLevel(logLevel: LogLevel): void;
    send(cname: ChannelName, message: Message, from?: SentFrom): boolean;
    error(cname: ChannelName, err: any): boolean;
    tickEventLoop(func: Function, delay?: number): number;
    request<R, E = any>(handlerConfig: MessageHandlerConfig, name?: SentFrom, id?: UUID): MessageHandler<R, E>;
    respond<R, E = any>(handlerConfig: MessageHandlerConfig, name?: SentFrom): MessageResponder<R, E>;
    listen<R>(handlerConfig: MessageHandlerConfig, requestStream?: boolean, name?: SentFrom, id?: UUID): MessageHandler<R>;
    setUpNgViewRefreshScheduler(): void;
    /**
     * PRIVATE METHODS.
     */
    /**
     * Create a message Responder.
     *
     * @param {MessageHandlerConfig} handlerConfig
     * @param {string} name
     * @param schema
     * @returns {MessageResponder<T, E>}
     */
    private createMessageResponder;
    private sendSubscribedMonitorMessage;
    private sendUnsubscribedMonitorMessage;
    /**
     * Create a message handler.
     * @param {MessageHandlerConfig} handlerConfig
     * @param {boolean} requestStream
     * @param {string} name
     * @returns {MessageHandler<any>}
     */
    private createMessageHandler;
    /**
     * Destroy a Channel and remove it from our map. If it is not closed, close it first.
     *
     * @param {Channel} channel
     * @param {string} from
     * @returns {boolean}
     */
    private destroy;
    /**
     * Dump data flowing through the monitor API into the console.
     *
     * @param {MonitorObject} mo
     * @param {string} tag
     */
    private dumpData;
    /**
     * This is a listener on the monitor channel which dumps message events to the console
     */
    private monitorBus;
}
