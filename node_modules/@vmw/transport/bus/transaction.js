/*
 * Copyright 2018-2020 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { TransactionType } from '../bus.api';
import { TransactionRequestImpl, TransactionReceiptImpl } from './model/transaction.model';
import { Subject } from 'rxjs';
import { GeneralUtil } from '../util/util';
/**
 * Copyright(c) VMware Inc. 2016-2018
 */
export class BusTransactionImpl {
    constructor(bus, logger, transactionType = TransactionType.ASYNC, name = 'BusTransaction') {
        this.completed = false;
        this.transactionCompleteError = null;
        this.bus = bus;
        this.log = logger;
        this.transactionType = transactionType;
        this.requests = [];
        this.name = name;
        this.id = GeneralUtil.genUUID();
        this.transactionErrorChannel = 'transaction-' + this.id + '-errors';
        this.log.info('üè¶ Transaction Created', this.transactionName());
    }
    waitForStoreReady(store) {
        if (this.completed) {
            this.transactionCompletedMessage('cannot queue a new cache initialization via waitForCacheReady()');
            throw this.transactionCompleteError;
        }
        const req = new TransactionRequestImpl(null, null, store);
        this.requests.push(req);
        this.log.debug('‚è≥ Transaction: Store Request Queued: [' + req.id + ']', this.transactionName());
    }
    //private requests
    sendRequest(channel, payload) {
        if (this.completed) {
            this.transactionCompletedMessage('cannot queue a new request via sendRequest()');
            throw this.transactionCompleteError;
        }
        const req = new TransactionRequestImpl(channel, payload);
        this.requests.push(req);
        this.log.debug('‚è≥ Transaction: Bus Request Queued: [' + req.id + ']', this.transactionName());
    }
    onComplete(completeHandler) {
        if (this.completed) {
            this.transactionCompletedMessage('cannot register onComplete() handler');
            throw this.transactionCompleteError;
        }
        this.log.debug('üëã Transaction: Completed Handler Registered', this.transactionName());
        this.completedHandler = completeHandler;
    }
    commit() {
        if (this.completed) {
            this.transactionCompletedMessage('cannot re-commit transaction via commit()');
            throw this.transactionCompleteError;
        }
        if (this.requests.length <= 0) {
            throw new Error('Transaction cannot be committed, no requests made.');
        }
        this.transactionReceipt = new TransactionReceiptImpl(this.requests.length, this.id);
        switch (this.transactionType) {
            case TransactionType.ASYNC:
                this.startAsyncTransaction();
                break;
            case TransactionType.SYNC:
                this.startSyncTransaction();
                break;
            default:
                break;
        }
        return this.transactionReceipt;
    }
    onError(errorHandler) {
        if (this.completed) {
            this.transactionCompletedMessage('cannot register new error handler via onError()');
            throw this.transactionCompleteError;
        }
        this.bus.listenOnce(this.transactionErrorChannel)
            .handle((error) => {
            this.log.error('Transaction [' + this.id + ']', error);
            this.transactionErrored();
            errorHandler(error);
        });
    }
    sendRequestAndListen(request, responseHandler, type) {
        this.log.debug('‚û°Ô∏è Transaction: Sending ' + type + ' Request to channel: '
            + request.channel, this.transactionName());
        // use message ID's to make sure we only react to each explicit response
        const mId = request.payload && request.payload.id ? request.payload.id : GeneralUtil.genUUID();
        const handler = this.bus.listenStream(request.channel, this.name, mId);
        let handlerCallsCount = 0;
        handler.handle((response) => {
            handlerCallsCount++;
            this.log.debug('‚¨ÖÔ∏è Transaction: Received ' + type + ' Response on channel: '
                + request.channel + ' - ' + response, this.transactionName());
            responseHandler(response);
            if (handlerCallsCount >= this.getExpectedHandlerCalls(request)) {
                handler.close();
            }
        }, (error, args) => {
            handlerCallsCount++;
            // send to onError handler.
            this.bus.sendResponseMessageWithId(this.transactionErrorChannel, error, mId);
            if (handlerCallsCount >= this.getExpectedHandlerCalls(request)) {
                handler.close();
            }
        });
        this.bus.sendRequestMessageWithId(request.channel, request.payload, mId);
    }
    transactionErrored() {
        this.bus.closeChannel(this.transactionErrorChannel);
        this.transactionReceipt.complete = true;
        this.transactionReceipt.completedTime = new Date();
        this.transactionCompleted();
    }
    transactionCompleteHandler(responses) {
        this.transactionReceipt.complete = true;
        this.transactionReceipt.completedTime = new Date();
        this.transactionCompleted();
        this.completedHandler(responses);
    }
    startAsyncTransaction() {
        this.log.info('üè¶ Transaction: Starting Asynchronous', this.transactionName());
        let responses = new Array();
        const requestList = this.requests.slice();
        let counter = 0;
        // create async response handler for requests/responses.
        const handler = (response) => {
            counter++;
            responses.push(response);
            const totalExpectedHandlerCalls = requestList.map((request) => this.getExpectedHandlerCalls(request)).reduce((prev, curr) => prev + curr);
            this.transactionReceipt.requestsCompleted++;
            if (counter >= totalExpectedHandlerCalls) {
                this.transactionCompleteHandler(responses);
                return;
            }
        };
        // started transaction
        this.transactionReceipt.startedTime = new Date();
        requestList.forEach((request) => {
            this.transactionReceipt.requestsSent++;
            if (!request.store) {
                this.sendRequestAndListen(request, handler, TransactionType.ASYNC);
            }
            else {
                this.log.info('‚è±Ô∏è Transaction: Waiting for Store: ' + request.store, this.transactionName());
                this.bus.stores.createStore(request.store).whenReady(handler);
            }
        });
    }
    transactionName() {
        return this.name + '.' + this.id;
    }
    startSyncTransaction() {
        this.syncStream = new Subject();
        this.log.info('üè¶ Transaction: Starting Synchronous', this.transactionName());
        let responses = new Array();
        const requestList = this.requests.slice();
        let counter = 0;
        for (let x = 0; x < requestList.length; x++) {
            if (x >= 0 && x < requestList.length) {
                requestList[x].nextRequest = requestList[x + 1];
            }
        }
        this.syncStream.subscribe((req) => {
            const responseHandler = (response) => {
                counter++;
                responses.push(response);
                this.transactionReceipt.requestsCompleted++;
                const totalExpectedHandlerCalls = requestList.map((request) => this.getExpectedHandlerCalls(request)).reduce((prev, curr) => prev + curr);
                if (req.nextRequest) {
                    this.syncStream.next(req.nextRequest);
                }
                if (counter >= totalExpectedHandlerCalls) {
                    this.syncStream.complete();
                }
            };
            this.transactionReceipt.requestsSent++;
            if (!req.store) {
                this.sendRequestAndListen(req, responseHandler, TransactionType.ASYNC);
            }
            else {
                this.log.info('‚è±Ô∏è Transaction: Waiting for Store: ' + req.store, this.transactionName());
                this.bus.stores.createStore(req.store).whenReady(responseHandler);
            }
        }, () => null, () => {
            this.transactionCompleteHandler(responses);
        });
        this.syncStream.next(requestList[0]);
    }
    transactionCompleted() {
        this.completed = true;
        this.transactionCompleteError = new Error('transaction ' + this.id + ' has already completed');
        this.log.info('üéâ Transaction Completed', this.transactionName());
    }
    transactionCompletedMessage(msg) {
        this.log.warn('Transaction Complete: ' + msg, this.transactionName());
    }
    getExpectedHandlerCalls(request) {
        const matchingGalacticChannelRef = this.bus.brokerConnector.galacticChannels.get(request.channel);
        const isGalacticRequest = this.bus.brokerConnector.galacticChannels.has(request.channel) &&
            matchingGalacticChannelRef.connectedBrokers > 0;
        const expectedNumOfHandlerCalls = isGalacticRequest ? matchingGalacticChannelRef.connectedBrokers : 1;
        return expectedNumOfHandlerCalls;
    }
}
//# sourceMappingURL=transaction.js.map