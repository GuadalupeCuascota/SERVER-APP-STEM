/*
 * Copyright 2017-2019 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { Subject } from 'rxjs';
import { StompParser } from '../../bridge/stomp.parser';
import { GeneralUtil } from '../../util/util';
export class Channel {
    constructor(name) {
        this._name = name;
        this._refCount = 0;
        this._streamObject = new Subject();
        this._closed = false;
        this._galactic = false;
        this._private = false;
        this.subscribers = new Map();
        this.observers = new Map();
    }
    /**
     * Returns the stream object for subscription
     *
     * @returns {Subject<Message>}
     */
    get stream() {
        return this._streamObject;
    }
    createSubscriber() {
        const id = StompParser.genUUID();
        this.subscribers.set(id, { id: id, subscribed: new Date().getDate() });
        return id;
    }
    removeSubscriber(uuid) {
        return this.subscribers.delete(uuid);
    }
    getSubscriber(uuid) {
        return this.subscribers.get(uuid);
    }
    createObserver() {
        const id = GeneralUtil.genUUID();
        this.observers.set(id, { id: id, subscribed: new Date().getDate() });
        this.latestObserver = id;
        return id;
    }
    removeObserver(uuid) {
        return this.observers.delete(uuid);
    }
    getObserver(uuid) {
        return this.observers.get(uuid);
    }
    /**
     * returns the channel identifier
     *
     * @returns {string}
     */
    get name() {
        return this._name;
    }
    /**
     * returns state of stream.
     *
     * @returns {boolean}
     */
    get isClosed() {
        return this._closed;
    }
    /**
     * Transmit data on the stream after switching to event loop.
     *
     * @param message Message
     */
    send(message) {
        setTimeout(() => {
            this._streamObject.next(message);
        });
    }
    /**
     * Transmit an error on the stream
     *
     * @param err
     */
    error(err) {
        this._streamObject.error(err);
    }
    /**
     * Transmit a completion on the stream
     */
    complete() {
        this._closed = true;
        this._streamObject.complete();
    }
    increment() {
        return ++this._refCount;
    }
    decrement() {
        if (this._refCount > 0) {
            --this._refCount;
        }
        return this._refCount;
    }
    get refCount() {
        return this._refCount;
    }
    setGalactic() {
        this._galactic = true;
        return this;
    }
    setLocal() {
        this._galactic = false;
        return this;
    }
    get galactic() {
        return this._galactic;
    }
    setPrivate() {
        this._private = true;
    }
    setPublic() {
        this._private = false;
    }
    get isPrivate() {
        return this._private;
    }
}
//# sourceMappingURL=channel.model.js.map