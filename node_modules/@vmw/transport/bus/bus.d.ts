import { BusStoreApi } from '../store.api';
import { UUID } from './store/store.model';
import { StompBusCommand } from '../bridge/stomp.model';
import { BridgeConnectionAdvancedConfig } from '../bridge/bridge.model';
import { BusTransaction, ChannelBrokerMapping, ChannelName, EventBus, EventBusEnabled, EventBusLowApi, MessageFunction, MessageHandler, MessageResponder, SentFrom, TransactionType } from '../bus.api';
import { Logger } from '../log/logger.service';
import { LogLevel } from '../log/logger.model';
import { BrokerConnector } from '../bridge/broker-connector';
import { MessageProxyConfig, ProxyControl } from '../proxy/message.proxy.api';
import { FabricApi } from '../fabric.api';
import { NgZoneRef } from '.';
export declare class TransportEventBus extends EventBus implements EventBusEnabled {
    private static instance;
    /**
     * Destroy the bus completely.
     */
    static destroy(): void;
    static getInstance(): EventBus;
    /**
     * Boot and create a singleton EventBus instance with default options
     * @returns {EventBus} the bus.
     */
    static boot(): EventBus;
    /**
     * Boot and create a singleton EventBus instance with custom options for logging level and boot message
     * @param {LogLevel} logLevel log level to set
     * @param {boolean} disableBootMessage set to true to turn off the boot message.
     * @param {boolean} darkTheme enable dark theme logging (defaults to false)
     * @returns {EventBus} the bus
     */
    static bootWithOptions(logLevel: LogLevel, disableBootMessage: boolean, darkTheme?: boolean): EventBus;
    /**
     * Reboot the bus, critical for tests, reboot destroys the singleton and re-creates it.
     * @param {LogLevel} logLevel  log level to set
     * @param {boolean} disableBootMessage set true to turn off the boot message.
     * @returns {EventBus} the newly rebooted bus
     */
    static rebootWithOptions(logLevel: LogLevel, disableBootMessage: boolean): EventBus;
    /**
     * Reboot the bus, critical for tests, reboot destroys the singleton and re-creates it.
     * @returns {EventBus} the newly rebooted event bus.
     */
    static reboot(): EventBus;
    private internalChannelMap;
    private log;
    private windowRef;
    private messageProxy;
    private proxyControl;
    private devModeEnabled;
    readonly api: EventBusLowApi;
    readonly stores: BusStoreApi;
    readonly fabric: FabricApi;
    readonly brokerConnector: BrokerConnector;
    private constructor();
    zoneRef: NgZoneRef;
    get logger(): Logger;
    getName(): string;
    setNgZoneRef(ngZoneRef: NgZoneRef): void;
    destroy(): void;
    enableDevMode(): void;
    enableMessageProxy(config: MessageProxyConfig): ProxyControl;
    connectBridge(readyHandler: MessageFunction<string>, endpoint: string, topicLocation: string, queueLocation?: string, numBrokerRelays?: number, host?: string, port?: number, applicationDestinationPrefix?: string, user?: string, pass?: string, useSSL?: boolean, autoReconnect?: boolean, advancedConfig?: BridgeConnectionAdvancedConfig): MessageHandler<StompBusCommand>;
    listenGalacticStream<T>(cname: ChannelName, name?: SentFrom, galacticConfig?: ChannelBrokerMapping): MessageHandler<T>;
    isGalacticChannel(cname: ChannelName): boolean;
    closeGalacticChannel(cname: ChannelName, from?: SentFrom, brokerIdentity?: ChannelBrokerMapping): void;
    sendGalacticMessage(cname: ChannelName, payload: any, from?: SentFrom): void;
    sendRequestMessage(cname: ChannelName, payload: any, name?: string): void;
    sendRequestMessageWithId<R>(cname: string, payload: R, id: UUID, from?: string, proxyBroadcast?: boolean): void;
    sendRequestMessageWithIdAndVersion<R>(cname: string, payload: R, id: UUID, version: number, from?: string, proxyBroadcast?: boolean): void;
    sendResponseMessage(cname: ChannelName, payload: any, name?: string): boolean;
    sendResponseMessageWithId<R>(cname: string, payload: R, id: UUID, from?: string, proxyBroadcast?: boolean): void;
    sendResponseMessageWithIdAndVersion<R>(cname: string, payload: R, id: UUID, version: number, from?: string, proxyBroadcast?: boolean): void;
    sendErrorMessageWithId<E>(cname: ChannelName, payload: E, id: UUID, from?: SentFrom, proxyBroadcast?: boolean): void;
    sendErrorMessageWithIdAndVersion<E>(cname: ChannelName, payload: E, id: UUID, version: number, from?: SentFrom, proxyBroadcast?: boolean): void;
    sendErrorMessage(cname: ChannelName, payload: any, name?: string, proxyBroadcast?: boolean): void;
    respondOnce<R>(sendChannel: ChannelName, returnChannel?: ChannelName, name?: string): MessageResponder<R>;
    respondStream<R>(sendChannel: ChannelName, returnChannel?: ChannelName, name?: string): MessageResponder<R>;
    requestStream<T, R>(sendChannel: ChannelName, requestPayload: T, returnChannel?: ChannelName, name?: string): MessageHandler<R>;
    requestStreamWithId<T, R>(uuid: UUID, sendChannel: ChannelName, requestPayload: T, returnChannel?: ChannelName, name?: string): MessageHandler<R>;
    requestOnce<T, R>(sendChannel: ChannelName, requestPayload: T, returnChannel?: ChannelName, name?: string): MessageHandler<R>;
    requestOnceWithId<T, R>(uuid: UUID, sendChannel: ChannelName, requestPayload: T, returnChannel?: ChannelName, from?: SentFrom): MessageHandler<R>;
    listenOnce<R>(channel: ChannelName, name?: string, id?: UUID): MessageHandler<R>;
    listenStream<R>(channel: ChannelName, name?: string, id?: UUID): MessageHandler<R>;
    listenRequestOnce<R>(channel: ChannelName, name?: string, id?: UUID): MessageHandler<R>;
    listenRequestStream<R>(channel: ChannelName, name?: string, id?: UUID): MessageHandler<R>;
    closeChannel(cname: ChannelName, from?: SentFrom): boolean;
    createTransaction(type?: TransactionType, name?: string): BusTransaction;
    easterEgg(): void;
    markChannelsAsGalactic(channelNames: Iterable<ChannelName>): void;
    markChannelAsGalactic(channelName: ChannelName, brokerIdentity?: string, isPrivate?: boolean): void;
    markChannelsAsLocal(channelNames: Iterable<ChannelName>): void;
    markChannelAsLocal(channelName: ChannelName, brokerIdentity?: string): void;
}
