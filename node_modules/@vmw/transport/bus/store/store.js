/*
 * Copyright 2017-2019 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { merge } from 'rxjs';
import { map, filter } from 'rxjs/operators';
import { StoreStateChange, StoreStateMutation, StoreStreamImpl, MutateStreamImpl, MutationRequestWrapper } from './store.model';
import { GeneralUtil } from '../../util/util';
import { BrokerConnectorChannel, StompClient } from '../../bridge';
export class StoreImpl {
    constructor(bus, type, galacticStoreSyncChannel = null) {
        this.bus = bus;
        this.type = type;
        this.galacticStoreSyncChannel = galacticStoreSyncChannel;
        this.cacheInitialized = false;
        this.isGalactic = false;
        this.isGalactic = !!this.galacticStoreSyncChannel;
        this.cache = new Map();
        this.uuid = GeneralUtil.genUUID();
        this.cacheStreamChan = `stores::store-change-${this.uuid}-${type}`;
        this.cacheMutationChan = `stores::store-mutation-${this.uuid}-${type}`;
        this.cacheReadyChan = `stores::store-ready-${this.uuid}-${type}`;
        this.log = bus.api.logger();
        this.name = type;
        this.log.info(`ðŸ—„ï¸ Store: New Store [${type}] was created with id ${this.uuid}, named ${type}`);
        if (this.isGalactic) {
            this.initGalacticStore();
        }
    }
    getName() {
        return 'BusStore';
    }
    getObjectChannel(id) {
        return 'store-' + this.uuid + '-object-' + id;
    }
    initGalacticStore() {
        this.syncChannelMessageHandler =
            this.bus.listenStream(this.galacticStoreSyncChannel, this.getName());
        this.syncChannelMessageHandler.handle((response) => {
            if (!response || response.storeId !== this.type) {
                // the response is for another store
                return;
            }
            if (response.responseType === 'storeContentResponse') {
                this.galacticStoreVersion = response.storeVersion;
                this.cache.clear();
                Object.keys(response.items).forEach(key => this.cache.set(key, response.items[key]));
                this.initialize();
            }
            else if (response.responseType === 'updateStoreResponse') {
                if (response.storeVersion > this.galacticStoreVersion + 1) {
                    // If the backend store version is greater than local version + 1 this means
                    // that we have missed some store updates.
                    this.log.warn('Detected missing updates for store: ' + this.type);
                }
                this.galacticStoreVersion = Math.max(this.galacticStoreVersion, response.storeVersion);
                if (response.newItemValue === null || response.newItemValue === undefined) {
                    this.removeLocal(response.itemId, 'galacticSyncRemove');
                }
                else {
                    this.putLocal(response.itemId, response.newItemValue, 'galacticSyncUpdate');
                }
            }
        });
        this.requestStoreContent();
        // listen for STOMP connect events on broker connector channel to update
        // the store content.
        this.connectionMessageHandler = this.bus.listenStream(BrokerConnectorChannel.status);
        this.connectionMessageHandler.handle((busCommand) => {
            switch (busCommand.command) {
                case StompClient.STOMP_CONNECTED:
                    this.requestStoreContent();
                    break;
            }
        });
    }
    closeStore() {
        if (this.isGalacticStore()) {
            const closeStoreRequest = this.bus.fabric.generateFabricRequest('closeStore', {
                storeId: this.type
            });
            this.bus.sendGalacticMessage(this.galacticStoreSyncChannel, closeStoreRequest);
            if (this.syncChannelMessageHandler) {
                this.syncChannelMessageHandler.close();
            }
            if (this.connectionMessageHandler) {
                this.connectionMessageHandler.close();
            }
        }
    }
    requestStoreContent() {
        const openStoreRequest = this.bus.fabric.generateFabricRequest('openStore', {
            storeId: this.type
        });
        this.bus.sendGalacticMessage(this.galacticStoreSyncChannel, openStoreRequest);
    }
    sendChangeBroadcast(changeType, id, value) {
        const stateChange = new StoreStateChange(id, changeType, value);
        this.bus.sendResponseMessage(this.cacheStreamChan, stateChange, this.getName());
        this.bus.sendResponseMessage(this.getObjectChannel(id), stateChange, this.getName());
    }
    allValues() {
        return Array.from(this.cache.values());
    }
    allValuesAsMap() {
        return new Map(this.cache.entries());
    }
    populate(items) {
        if (this.cache.size === 0 && !this.isGalacticStore()) {
            this.cache = new Map(items.entries());
            this.log.info('ðŸ—„ï¸ Store: Populated with  ' + this.cache.size + ' values', this.type);
            this.initialize();
            return true;
        }
        return false;
    }
    put(id, value, state) {
        if (this.isGalacticStore()) {
            this.putGalactic(id, value, state);
        }
        else {
            this.putLocal(id, value, state);
        }
    }
    putLocal(id, value, state) {
        this.cache.set(id, value);
        this.sendChangeBroadcast(state, id, value);
        this.log.info('ðŸ—„ï¸ Store: Added new object with id: ' + id, this.type);
    }
    putGalactic(id, value, state) {
        const updateStoreRequest = this.bus.fabric.generateFabricRequest('updateStore', {
            storeId: this.type,
            clientStoreVersion: this.galacticStoreVersion,
            itemId: id,
            newItemValue: value
        });
        this.bus.sendGalacticMessage(this.galacticStoreSyncChannel, updateStoreRequest);
    }
    remove(id, state) {
        if (this.isGalacticStore()) {
            return this.removeGalactic(id, state);
        }
        else {
            return this.removeLocal(id, state);
        }
    }
    removeLocal(id, state) {
        if (this.cache.has(id)) {
            const obj = this.cache.get(id);
            this.sendChangeBroadcast(state, id, obj);
            this.cache.delete(id);
            this.bus.api.close(this.getObjectChannel(id), this.getName());
            this.log.info('ðŸ—„ï¸ Store: Removed object with id ' + id, this.type);
            return true;
        }
        return false;
    }
    removeGalactic(id, state) {
        if (this.cache.has(id)) {
            const updateStoreRequest = this.bus.fabric.generateFabricRequest('updateStore', {
                storeId: this.type,
                clientStoreVersion: this.galacticStoreVersion,
                itemId: id,
                newItemValue: null
            });
            this.bus.sendGalacticMessage(this.galacticStoreSyncChannel, updateStoreRequest);
            return true;
        }
        return false;
    }
    get(id) {
        return this.cache.get(id);
    }
    isGalacticStore() {
        return this.isGalactic;
    }
    onChange(id, ...stateChangeType) {
        const cacheStreamChan = this.bus.api.getResponseChannel(this.getObjectChannel(id), this.getName());
        const cacheErrorCan = this.bus.api.getErrorChannel(this.getObjectChannel(id), this.getName());
        const stream = merge(cacheStreamChan, cacheErrorCan)
            .pipe(map((msg) => {
            return msg.payload;
        }));
        const stateChangeFilter = (state) => {
            if (stateChangeType && stateChangeType.length > 0) {
                return (stateChangeType.indexOf(state.type) >= 0);
            }
            return true; // all states.
        };
        return new StoreStreamImpl(this.filterStream(stream, [stateChangeFilter]), this.log);
    }
    onAllChanges(...stateChangeType) {
        const cacheStreamChan = this.bus.api.getResponseChannel(this.cacheStreamChan, this.getName());
        const cacheErrorCan = this.bus.api.getErrorChannel(this.cacheStreamChan, this.getName());
        const stream = merge(cacheStreamChan, cacheErrorCan)
            .pipe(map((msg) => {
            return msg.payload;
        }));
        const stateChangeFilter = (state) => {
            if (stateChangeType && stateChangeType.length > 0) {
                return (stateChangeType.indexOf(state.type) >= 0);
            }
            return true; // all states.
        };
        return new StoreStreamImpl(this.filterStream(stream, [stateChangeFilter]), this.log);
    }
    filterStream(stream, filters) {
        filters.forEach((f) => {
            stream = stream.pipe(filter(f));
        });
        return stream.pipe(map((stateChange) => {
            return new MutationRequestWrapper(stateChange.value, null, null, stateChange.id, stateChange.type);
        }));
    }
    mutate(value, mutationType, successHandler, errorHandler) {
        const mutation = new StoreStateMutation(mutationType, value);
        mutation.errorHandler = errorHandler;
        mutation.successHandler = successHandler;
        this.bus.sendRequestMessage(this.cacheMutationChan, mutation, this.getName());
        this.log.debug('ðŸ—„ï¸ Store: Fired mutation command', this.type);
        return true;
    }
    onMutationRequest(objectType, ...mutationType) {
        const stream = this.bus.api.getChannel(this.cacheMutationChan, this.getName())
            .pipe(map((msg) => {
            return msg.payload;
        }));
        const filterStream = stream.pipe(filter((mutation) => {
            if (mutationType && mutationType.length > 0) {
                return (mutationType.indexOf(mutation.type) >= 0);
            }
            return true;
        }), map((stateChange) => {
            return new MutationRequestWrapper(stateChange.value, stateChange.successHandler, stateChange.errorHandler);
        }));
        return new MutateStreamImpl(filterStream, this.log);
    }
    reset() {
        this.cache.clear();
        this.cacheInitialized = false;
        this.log.warn(`ðŸ—„ï¸ Store: [${this.name}] (${this.uuid}) has been reset. All data wiped `, this.name);
        if (this.isGalacticStore()) {
            this.requestStoreContent();
        }
    }
    whenReady(readyFunction) {
        this.bus.listenOnce(this.cacheReadyChan).handle(readyFunction);
        // push this off into the event loop, make sure all consumers are async.
        setTimeout(() => {
            if (this.cacheInitialized) {
                this.log.debug(`ðŸ—„ï¸ Store: [${this.name}] (${this.uuid}) Ready! Contains ${this.allValuesAsMap().size} values`, this.name);
                this.bus.sendResponseMessage(this.cacheReadyChan, this.allValuesAsMap());
            }
        });
    }
    initialize() {
        if (!this.cacheInitialized) {
            this.cacheInitialized = true;
            this.log.info('ðŸ—„ï¸ Store: [' + this.type + '] Initialized!', this.type);
            this.bus.sendResponseMessage(this.cacheReadyChan, this.allValuesAsMap());
        }
    }
    startAutoReload(timeToLiveInMs = 10000) {
        if (this.isGalacticStore()) {
            this.log.warn('Called startAutoReload() API on galactic store: ' + this.type);
            return;
        }
        this.reloadTTL = timeToLiveInMs;
        this.stopAutoReload(); // stop any existing reload interval
        if (timeToLiveInMs > 0 && this.reloadHandler) {
            this.reloadIntervalTracker = setInterval(() => {
                this.reloadHandler();
            }, timeToLiveInMs);
        }
    }
    stopAutoReload() {
        if (this.isGalacticStore()) {
            this.log.warn('Called stopAutoReload() API on galactic store: ' + this.type);
            return;
        }
        if (this.reloadIntervalTracker) {
            clearInterval(this.reloadIntervalTracker);
        }
    }
    refreshApiDelay() {
        if (this.isGalacticStore()) {
            this.log.warn('Called refreshApiDelay() API on galactic store: ' + this.type);
            return;
        }
        this.stopAutoReload();
        if (this.reloadHandler) {
            this.reloadIntervalTracker = setInterval(() => {
                this.reloadHandler();
            }, this.reloadTTL);
        }
        else {
            this.log.warn(`Unable to refresh API delay for ${this.name}, no reloadHandler has been defined.`, this.getName());
        }
    }
    reloadStore() {
        if (this.isGalacticStore()) {
            this.log.warn('Called reloadStore() API on galactic store: ' + this.type);
            return;
        }
        this.refreshApiDelay();
        if (this.reloadHandler) {
            this.reloadHandler();
        }
        else {
            this.log.warn(`Unable to reload store ${this.name}, no reloadHandler has been defined.`, this.getName());
        }
    }
    setAutoReloadServiceTrigger(serviceCallFunction) {
        if (this.isGalacticStore()) {
            this.log.warn('Called setAutoReloadServiceTrigger() API on galactic store: ' + this.type);
            return;
        }
        this.reloadHandler = serviceCallFunction;
    }
}
//# sourceMappingURL=store.js.map