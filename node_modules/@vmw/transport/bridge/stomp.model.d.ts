import { Subject, Subscription } from 'rxjs';
import { StompClient } from './stomp.client';
import { UUID } from '../bus/store/store.model';
import { Logger } from '../log';
import { EventBus } from '../bus.api';
export declare type TransportSocket = WebSocket;
export declare class BrokerConnectorChannel {
    static connection: string;
    static subscription: string;
    static messages: string;
    static error: string;
    static status: string;
}
export interface StompMessage {
    command: string;
    headers: any;
    body: string;
    toString(): string;
}
export interface StompBusCommand {
    destination: string;
    session: string;
    command: string;
    payload: any;
}
export interface StompSubscription {
    session: string;
    destination: string;
    id: string;
    isQueue: boolean;
    brokerPrefix: string;
}
export declare class StompSession {
    private log;
    private bus?;
    private _id;
    private _subscriptions;
    private _client;
    private _config;
    private galacticSubscriptions;
    private isConnected;
    private connCount;
    private _applicationDestinationPrefix;
    constructor(config: StompConfig, log: Logger, bus?: EventBus);
    get connected(): boolean;
    set connected(val: boolean);
    get connectionCount(): number;
    set connectionCount(val: number);
    get config(): StompConfig;
    get client(): StompClient;
    get id(): string;
    get applicationDestinationPrefix(): string;
    connect(messageHeaders?: any): Subject<Boolean>;
    send(destination: string, messageHeaders?: any, body?: any): boolean;
    subscribe(destination: string, id: string, headers?: any): Subject<StompMessage>;
    unsubscribe(id: string, headers?: any): void;
    disconnect(messageHeaders?: any): void;
    addGalacticSubscription(chan: string, subscription: Subscription): void;
    getGalacticSubscription(chan: string): Subscription;
    removeGalacticSubscription(chan: string): void;
    getGalacticSubscriptions(): Map<string, Subscription>;
}
export declare class StompConfig {
    private _endpoint;
    private _host?;
    private _port?;
    private _user?;
    private _pass?;
    private _useSSL?;
    private _applicationDestinationPrefix?;
    private _requireACK?;
    private _heartbeatIn;
    private _heartbeatOut;
    private _useTopics;
    private _useQueues;
    private _topicLocation;
    private _queueLocation;
    private _startIntervalFunction;
    private _getAccessTokenFunction;
    private _accessTokenHeaderKey;
    private _sendAccessTokenDuringHandshake;
    private _protocols;
    private numBrokerConnect;
    connectionSubjectRef: Subject<Boolean>;
    sessionId: UUID;
    autoReconnect: boolean;
    static generate(endpoint: string, host?: string, port?: number, useSSL?: boolean, user?: string, pass?: string, applicationDesintationPrefix?: string): StompConfig;
    private _testMode;
    constructor(_endpoint: string, _host?: string, _port?: number, _user?: string, _pass?: string, _useSSL?: boolean, _applicationDestinationPrefix?: string, _requireACK?: boolean, _heartbeatIn?: number, _heartbeatOut?: number);
    set brokerConnectCount(count: number);
    get brokerConnectCount(): number;
    set topicLocation(val: string);
    get topicLocation(): string;
    set queueLocation(val: string);
    get queueLocation(): string;
    set useTopics(val: boolean);
    set useQueues(val: boolean);
    get useTopics(): boolean;
    get useQueues(): boolean;
    get host(): string;
    get endpoint(): string;
    get port(): number;
    get user(): string;
    get pass(): string;
    get useSSL(): boolean;
    get requireACK(): boolean;
    get testMode(): boolean;
    set testMode(val: boolean);
    get startIntervalFunction(): (handler: any, timeout?: any, ...args: any[]) => number;
    set startIntervalFunction(fn: (handler: any, timeout?: any, ...args: any[]) => number);
    set heartbeatIn(interval: number);
    get heartbeatIn(): number;
    set heartbeatOut(interval: number);
    get heartbeatOut(): number;
    set getAccessTokenFunction(value: () => string);
    get accessToken(): string;
    set accessTokenHeaderKey(value: string);
    get accessTokenHeaderKey(): string;
    set sendAccessTokenDuringHandshake(value: boolean);
    get sendAccessTokenDuringHandshake(): boolean;
    set protocols(value: Array<string>);
    get protocols(): Array<string>;
    getConfig(): any;
    get applicationDestinationPrefix(): string;
    get config(): Object;
    generateSocket(): any;
    generateConnectionURI(): string;
}
