import { StompBusCommand, StompConfig, StompSession, StompSubscription } from '../bridge/stomp.model';
import { TransportEventBus } from '../bus/bus';
import { EventBus, EventBusEnabled } from '../bus.api';
import { Logger } from '../log';
/**
 * Service is responsible for handling all STOMP communications over a socket.
 */
export declare class BrokerConnector implements EventBusEnabled {
    private log;
    static serviceName: string;
    reconnectDelay: number;
    connectDelay: number;
    connectingMap: Map<string, boolean>;
    private currentSessionMap;
    private channelBrokerIdentitiesMap;
    static fireSubscriptionCommand(bus: EventBus, sessionId: string, destination: string, subscriptionId: string, subType: string, isQueue: boolean, brokerPrefix: string): void;
    static fireSubscribeCommand(bus: EventBus, sessionId: string, destination: string, subscriptionId: string, isQueue: boolean, brokerPrefix: string): void;
    static fireUnSubscribeCommand(bus: EventBus, sessionId: string, destination: string, subscriptionId: string, isQueue: boolean, brokerPrefix: string): void;
    static fireConnectCommand(bus: EventBus, config?: StompConfig): void;
    static fireDisconnectCommand(bus: EventBus, sessionId: string): void;
    constructor(log: Logger);
    getName(): string;
    private _errorObservables;
    private _closeObservables;
    private _sessions;
    private _galacticChannels;
    private _privateChannels;
    private bus;
    private reconnectTimerInstance;
    private reconnecting;
    setBus(bus: TransportEventBus): void;
    init(bus: TransportEventBus): void;
    get galacticChannels(): Map<string, {
        connectedBrokers: number;
    }>;
    get privateChannels(): Map<string, {
        [brokerIdentity: string]: boolean;
    }>;
    getSession(id: string): StompSession;
    get sessions(): Map<string, StompSession>;
    private processMonitorStreamMessage;
    private sendGalacticMessage;
    private generateSubscriptionId;
    private openGalacticChannel;
    private closeGalacticChannel;
    private processSubscriptionMessage;
    private processConnectionMessage;
    private sendBusCommandResponseRaw;
    private sendBusCommandResponse;
    private getGlobalHeaders;
    connectClient(config: StompConfig): void;
    disconnectClient(sessionId: string): void;
    sendPacket(data: StompBusCommand): void;
    private clearGalacticSubscriptionsFromSession;
    private reconnectTimer;
    private subscribeToClientObservables;
    subscribeToDestination(data: StompSubscription): void;
    unsubscribeFromDestination(data: StompSubscription): void;
    /**
     * Return true if session is established with the broker identified in galacticConfig
     * @param {ChannelBrokerMapping} galacticConfig
     * @return {boolean} true if session is established with the broker
     */
    private isSessionEstablished;
    /**
     * Return default brokerIdentity.
     * @return {string} broker identity if there is only one session or
     *         null if there more than one STOMP session is present
     */
    private getDefaultBrokerIdentity;
}
