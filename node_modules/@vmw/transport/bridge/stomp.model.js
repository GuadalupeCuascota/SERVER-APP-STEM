/*
 * Copyright 2017-2019 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { StompClient } from './stomp.client';
import { MockSocket } from './stomp.mocksocket';
import { GeneralUtil } from '../util/util';
import { DEFAULT_ACCESS_TOKEN_KEY } from '../fabric/fabric';
export class BrokerConnectorChannel {
}
BrokerConnectorChannel.connection = 'transport-services::broker.connector-connection';
BrokerConnectorChannel.subscription = 'transport-services::broker.connector-subscription';
BrokerConnectorChannel.messages = 'transport-services::broker.connector-messages';
BrokerConnectorChannel.error = 'transport-services::broker.connector-error';
BrokerConnectorChannel.status = 'transport-services::broker.connector-status';
// session help for each broker connection
export class StompSession {
    constructor(config, log, bus) {
        this.log = log;
        this.bus = bus;
        this.isConnected = false;
        this.connCount = 0;
        this._config = config;
        this._client = new StompClient(log, bus);
        this._id = GeneralUtil.genUUID();
        if (config.sessionId) {
            this._id = config.sessionId;
        }
        this._subscriptions = new Map();
        this.galacticSubscriptions = new Map();
        if (config.applicationDestinationPrefix) {
            this._applicationDestinationPrefix = config.applicationDestinationPrefix;
        }
    }
    get connected() {
        return this.isConnected;
    }
    set connected(val) {
        this.isConnected = val;
    }
    get connectionCount() {
        return this.connCount;
    }
    set connectionCount(val) {
        this.connCount = val;
    }
    get config() {
        return this._config;
    }
    get client() {
        return this._client;
    }
    get id() {
        return this._id;
    }
    get applicationDestinationPrefix() {
        return this._applicationDestinationPrefix;
    }
    connect(messageHeaders) {
        return this._client.connect(this._config, messageHeaders);
    }
    send(destination, messageHeaders, body) {
        return this._client.send(destination, messageHeaders, body);
    }
    subscribe(destination, id, headers) {
        let subject = this._client.subscribeToDestination(destination, id, headers);
        this._subscriptions.set(id, subject);
        return subject;
    }
    unsubscribe(id, headers) {
        this._client.unsubscribeFromDestination(id, headers);
        this._subscriptions.delete(id);
    }
    disconnect(messageHeaders) {
        this._client.disconnect(messageHeaders);
    }
    addGalacticSubscription(chan, subscription) {
        if (!this.galacticSubscriptions.has(chan)) {
            this.galacticSubscriptions.set(chan, subscription);
        }
    }
    getGalacticSubscription(chan) {
        return this.galacticSubscriptions.get(chan);
    }
    removeGalacticSubscription(chan) {
        if (this.galacticSubscriptions.has(chan)) {
            this.galacticSubscriptions.delete(chan);
        }
    }
    getGalacticSubscriptions() {
        return this.galacticSubscriptions;
    }
}
// stomp config.
export class StompConfig {
    constructor(_endpoint, _host, _port, _user, _pass, _useSSL, _applicationDestinationPrefix, _requireACK, _heartbeatIn = 0, _heartbeatOut = 30000) {
        this._endpoint = _endpoint;
        this._host = _host;
        this._port = _port;
        this._user = _user;
        this._pass = _pass;
        this._useSSL = _useSSL;
        this._applicationDestinationPrefix = _applicationDestinationPrefix;
        this._requireACK = _requireACK;
        this._heartbeatIn = _heartbeatIn;
        this._heartbeatOut = _heartbeatOut;
        this._useTopics = true;
        this._useQueues = false;
        this._topicLocation = '/topic';
        this._queueLocation = '/queue';
        this._accessTokenHeaderKey = DEFAULT_ACCESS_TOKEN_KEY;
        this._sendAccessTokenDuringHandshake = false;
        this.numBrokerConnect = 1;
        this.autoReconnect = true;
        this._testMode = false;
    }
    static generate(endpoint, host, port, useSSL, user, pass, applicationDesintationPrefix) {
        return new StompConfig(endpoint, host, port, user, pass, useSSL, applicationDesintationPrefix);
    }
    set brokerConnectCount(count) {
        this.numBrokerConnect = count;
    }
    get brokerConnectCount() {
        return this.numBrokerConnect;
    }
    set topicLocation(val) {
        this._topicLocation = val;
    }
    get topicLocation() {
        return this._topicLocation;
    }
    set queueLocation(val) {
        this._queueLocation = val;
    }
    get queueLocation() {
        return this._queueLocation;
    }
    set useTopics(val) {
        this._useTopics = val;
    }
    set useQueues(val) {
        this._useQueues = val;
    }
    get useTopics() {
        return this._useTopics;
    }
    get useQueues() {
        return this._useQueues;
    }
    get host() {
        return this._host;
    }
    get endpoint() {
        return this._endpoint;
    }
    get port() {
        return this._port;
    }
    get user() {
        return this._user;
    }
    get pass() {
        return this._pass;
    }
    get useSSL() {
        return this._useSSL;
    }
    get requireACK() {
        return this._requireACK;
    }
    get testMode() {
        return this._testMode;
    }
    set testMode(val) {
        this._testMode = val;
    }
    get startIntervalFunction() {
        return this._startIntervalFunction;
    }
    set startIntervalFunction(fn) {
        this._startIntervalFunction = fn;
    }
    set heartbeatIn(interval) {
        this._heartbeatIn = interval;
    }
    get heartbeatIn() {
        return this._heartbeatIn;
    }
    set heartbeatOut(interval) {
        this._heartbeatOut = interval;
    }
    get heartbeatOut() {
        return this._heartbeatOut;
    }
    set getAccessTokenFunction(value) {
        this._getAccessTokenFunction = value;
    }
    get accessToken() {
        if (!this._getAccessTokenFunction) {
            throw new Error('getAccessTokenFunction not set');
        }
        return this._getAccessTokenFunction();
    }
    set accessTokenHeaderKey(value) {
        this._accessTokenHeaderKey = value;
    }
    get accessTokenHeaderKey() {
        return this._accessTokenHeaderKey;
    }
    set sendAccessTokenDuringHandshake(value) {
        this._sendAccessTokenDuringHandshake = value;
    }
    get sendAccessTokenDuringHandshake() {
        return this._sendAccessTokenDuringHandshake;
    }
    set protocols(value) {
        this._protocols = value;
    }
    get protocols() {
        return this._protocols;
    }
    getConfig() {
        return {
            endpoint: this._endpoint,
            host: this._host,
            port: this._port,
            user: this._user,
            pass: this._pass,
            requireACK: this._requireACK,
            useSSL: this._useSSL,
            heartbeatIn: this._heartbeatIn,
            heartbeatOut: this._heartbeatOut,
            applicationDestinationPrefix: this._applicationDestinationPrefix,
            startIntervalFunction: this._startIntervalFunction
        };
    }
    get applicationDestinationPrefix() {
        return this._applicationDestinationPrefix;
    }
    /* same as getConfig() just cleaner */
    get config() {
        return this.getConfig();
    }
    generateSocket() {
        let protocols = this.protocols;
        if (protocols) {
            // Make sure we don't mutate the client's array.
            protocols = protocols.slice();
        }
        if (this.sendAccessTokenDuringHandshake) {
            const accessToken = this.accessToken;
            const accessTokenProtocol = `${this.accessTokenHeaderKey}.${accessToken}`;
            if (!protocols) {
                protocols = [];
            }
            protocols.push(accessTokenProtocol);
        }
        if (this._testMode) {
            return new MockSocket(this.generateConnectionURI(), protocols);
        }
        else {
            return new WebSocket(this.generateConnectionURI(), protocols);
        }
    }
    generateConnectionURI() {
        let scheme = window.location.protocol === 'https:' ? 'wss' : 'ws';
        let hostPort = window.location.host;
        if (this._useSSL) {
            scheme = 'wss';
        }
        if (this._host) {
            hostPort = this._host;
        }
        if (this._port && this._port !== -1) {
            hostPort += ':' + this._port;
        }
        return scheme + '://'
            + hostPort
            + this._endpoint;
    }
}
//# sourceMappingURL=stomp.model.js.map