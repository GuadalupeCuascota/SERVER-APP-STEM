/*
 * Copyright 2017-2019 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { Subject, fromEvent } from 'rxjs';
import { StompParser } from './stomp.parser';
import { map } from 'rxjs/operators';
import { GeneralUtil } from '../util/util';
import { FabricConnectionState } from '../fabric.api';
export var ConnectionState;
(function (ConnectionState) {
    ConnectionState[ConnectionState["Connecting"] = 0] = "Connecting";
    ConnectionState[ConnectionState["Connected"] = 1] = "Connected";
    ConnectionState[ConnectionState["Disconnected"] = 2] = "Disconnected";
})(ConnectionState || (ConnectionState = {}));
export class StompClient {
    constructor(log, bus) {
        this.log = log;
        this.bus = bus;
        this._socketConnected = false;
        this._stompConnected = false;
        this._useMockSocket = false;
        this._transactionReceipts = new Map();
        this._subscriptions = new Map();
        this._stompConnectedObserver = new Subject();
        this._ackObserver = new Subject();
        this._subscriptionObserver = new Subject();
        this.currentConnectionState = ConnectionState.Disconnected;
    }
    getName() {
        return this.constructor.name;
    }
    getSubscription(id) {
        if (this._subscriptions.has(id)) {
            return this._subscriptions.get(id);
        }
        return null;
    }
    get connectionState() {
        return this.currentConnectionState;
    }
    get clientSocket() {
        return this._socket;
    }
    get socketOpenObserver() {
        if (this._socketOpenObserver) {
            return this._socketOpenObserver;
        }
        return null;
    }
    get socketMessageObserver() {
        if (this._socketMessageObserver) {
            return this._socketMessageObserver;
        }
        return null;
    }
    get socketCloseObserver() {
        if (this._socketCloseObserver) {
            return this._socketCloseObserver;
        }
        return null;
    }
    get socketErrorObserver() {
        if (this._socketErrorObserver) {
            return this._socketErrorObserver;
        }
        return null;
    }
    get socketConnectedObserver() {
        return this._stompConnectedObserver;
    }
    get socketACKObserver() {
        return this._ackObserver;
    }
    get socketSubscriptionObserver() {
        return this._subscriptionObserver;
    }
    useMockSocket() {
        this._useMockSocket = true;
    }
    connect(config, messageHeaders) {
        if (this._socket && this._stompConnectedObserver !== null) {
            return this._stompConnectedObserver;
        }
        return this.create(config, messageHeaders);
    }
    disconnect(messageHeaders) {
        let headers = messageHeaders || {};
        if (this._socket) {
            headers.receipt = 'disconnect-' + GeneralUtil.genUUID();
            this.transmit(StompClient.STOMP_DISCONNECT, headers);
            this._socket.close();
        }
        else {
            this.log.warn('Uable to disconnect client, no socket open', this.getName());
        }
    }
    send(destination, messageHeaders, body) {
        let headers = messageHeaders || {};
        headers.destination = destination;
        return this.transmit(StompClient.STOMP_SEND, headers, body);
    }
    subscribeToDestination(destination, id, headers) {
        if (this.getSubscription(id) !== null) {
            return this.getSubscription(id);
        }
        headers = headers || {};
        headers.destination = destination;
        headers.id = id;
        // check if config requires ACK or not.
        if (this._config.getConfig().requireACK) {
            headers.ack = 'client';
        }
        let subscriptionSubject = new Subject();
        this._subscriptions.set(id, subscriptionSubject);
        this.transmit(StompClient.STOMP_SUBSCRIBE, headers);
        setTimeout(() => {
            this._subscriptionObserver.next(StompParser.frame(StompClient.STOMP_SUBSCRIBE, headers));
        });
        return subscriptionSubject;
    }
    unsubscribeFromDestination(id, headers) {
        headers = headers || {};
        headers.id = id;
        this.transmit(StompClient.STOMP_UNSUBSCRIBE, headers);
        setTimeout(() => {
            let subscription = this.getSubscription(id);
            if (subscription) {
                subscription.complete();
                this.deleteSubscription(id);
            }
            else {
                this.log.debug('Tried to complete subscription that did not exist: ' + id, this.getName());
            }
        });
    }
    beginTransaction(transactionId, header) {
        let headers = header || {};
        headers.transaction = GeneralUtil.genUUID();
        if (transactionId) {
            headers.transaction = transactionId;
        }
        if (!headers.receipt) {
            headers.receipt = GeneralUtil.genUUID();
        }
        // store this receipt so we can let the user know if/when we get a notification back.
        let transactionSubject = new Subject();
        this._transactionReceipts.set(headers.receipt, transactionSubject);
        let txWrapper = {
            id: headers.transaction,
            receiptId: headers.receipt,
            receiptObservable: transactionSubject,
            commit: () => {
                this.commit(headers.transaction);
            },
            abort: () => {
                this.abort(headers.transaction);
            },
        };
        this.log.debug('Starting STOMP Transaction: ' + headers.transaction, this.getName());
        this.transmit(StompClient.STOMP_BEGIN, headers);
        return txWrapper;
    }
    deleteSubscription(id) {
        this._subscriptions.delete(id);
    }
    onStompError(frame) {
        this.log.error('Error with STOMP Client on WebSocket: ' + frame.command + frame.body, this.getName());
        this.sendStompErrorToSubscribers(frame.headers, frame.body);
    }
    onError(err) {
        let frame;
        try {
            frame = StompParser.unmarshal(err.data);
        }
        catch (e) {
            this.log.info('Error is not STOMP packet, cannot be unmarshalled', this.getName());
        }
        this.currentConnectionState = ConnectionState.Disconnected;
        // switch connection state to error for fabric consumers.
        if (this.bus) {
            const connString = GeneralUtil.getFabricConnectionString(this._config.host, this._config.port, this._config.endpoint);
            this.log.debug('Informing Fabric subscribers that the connection has failed via store.', this.getName());
            this.bus.fabric
                .getConnectionStateStore(connString)
                .put(connString, FabricConnectionState.Failed, FabricConnectionState.Failed);
        }
        this.log.error('Error with WebSocket, Connection Failed', this.getName());
        if (frame && frame.hasOwnProperty('headers')) {
            this.sendStompErrorToSubscribers(frame.headers, 'Error occurred with WebSocket');
        }
    }
    onClose(config) {
        setTimeout(() => {
            this._subscriptions.forEach((subscriber, id) => {
                this.log.debug('Unsubscribing: ' + id, this.getName());
                //subscriber.complete();
                this.deleteSubscription(id);
            });
            this.log.info('WebSocket has been closed', this.getName());
        });
        this.currentConnectionState = ConnectionState.Disconnected;
        this._socketConnected = false;
        this._stompConnectedObserver = null;
        if (this._heartbeater) {
            clearInterval(this._heartbeater);
        }
    }
    sendHeartbeat() {
        this._socket.send('\n');
    }
    onOpen(evt, messageHeaders) {
        this._socketConnected = true;
        this.log.debug('WebSocket opened', this.getName());
        const headers = Object.assign({
            login: this._config.getConfig().user,
            passcode: this._config.getConfig().pass,
            'heart-beat': this._config.getConfig().heartbeatOut +
                ',' + this._config.getConfig().heartbeatIn
        }, messageHeaders ? messageHeaders : {});
        this.transmit(StompClient.STOMP_CONNECT, headers);
        if (this._config.getConfig().heartbeatOut
            && this._config.getConfig().heartbeatOut > 0) {
            let startIntervalFn = this._config.getConfig().startIntervalFunction || setInterval;
            //set up an interval to send a null char down the pipe;
            this._heartbeater = startIntervalFn(() => {
                this.sendHeartbeat();
            }, this._config.getConfig().heartbeatOut);
        }
    }
    transmit(command, headers, body) {
        if (body instanceof ArrayBuffer) {
            body = StompParser.bufferToString(body);
        }
        return this.sendSocketMessage(StompParser
            .marshal(command, headers, body), command, headers);
    }
    ack(messageId, header) {
        let headers = header || {};
        headers['id'] = messageId;
        this.transmit(StompClient.STOMP_ACK, headers);
        this._ackObserver.next(StompParser.frame(StompClient.STOMP_ACK, headers));
    }
    commit(txId) {
        let headers = { transaction: txId };
        this.log.debug('STOMP transaction COMMIT: ' + txId, this.getName());
        this.transmit(StompClient.STOMP_COMMIT, headers);
    }
    abort(txId) {
        let headers = { transaction: txId };
        this.log.debug('STOMP transaction ABORT: ' + txId, this.getName());
        this.transmit(StompClient.STOMP_ABORT, headers);
    }
    onMessage(evt) {
        let data = evt.data;
        if (data instanceof ArrayBuffer) {
            data = StompParser.bufferToString(data);
        }
        let frame = StompParser.unmarshal(data);
        switch (frame.command) {
            case StompClient.STOMP_CONNECTED:
                this.log.debug('STOMP client now connected, alerting subscribers', this.getName());
                this._stompConnected = true;
                this._stompConnectedObserver.next(true);
                this.currentConnectionState = ConnectionState.Connected;
                break;
            case StompClient.STOMP_MESSAGE:
                this.log.verbose('STOMP message received: ' + evt.data, this.getName());
                // the subscription ID should have been sent back from the server
                if (frame.headers.subscription) {
                    // ensure any services using '::' is replaced with \c\c (https://stomp.github.io/stomp-specification-1.2.html)
                    const subscription = frame.headers.subscription.replace(/\\c/g, ':');
                    if (this.getSubscription(subscription) !== null) {
                        this.getSubscription(subscription).next(frame);
                    }
                }
                if (this._config.getConfig().requireACK) { // config demands an ACK yo.
                    this.ack(frame.headers['message-id']);
                }
                break;
            case StompClient.STOMP_RECEIPT:
                let receiptId = frame.headers['receipt-id'];
                this.log.verbose('STOMP receipt received: ' + receiptId, this.getName());
                let subject = this._transactionReceipts.get(receiptId);
                if (subject) {
                    subject.next(frame);
                    subject.complete(); // done with this.
                }
                this._transactionReceipts.delete(receiptId); // don't need it anymore.
                if (this._config.getConfig().requireACK) {
                    this.ack(frame.headers['receipt-id']);
                }
                break;
            case StompClient.STOMP_ERROR:
                this.log.verbose('STOMP error received: ' + evt.data, this.getName());
                this.onStompError(frame);
                break;
            default:
                break;
        }
    }
    sendSocketMessage(data, command, headers) {
        let err = 'Unable to send STOMP frame, socket closed or in wrong state:';
        if (this._socket) {
            if (this._socket.readyState === WebSocket.OPEN) {
                this.log.debug('Sending STOMP frame down the wire', this.getName());
                this._socket.send(data);
                return true;
            }
            else {
                this.log.error(err, this.getName());
                this.sendStompErrorToSubscribers(headers, err);
                return false;
            }
        }
        this.log.debug(err, this.getName());
        return false;
    }
    sendStompErrorToSubscribers(headers, payload) {
        if (headers && headers.subscription !== null) {
            if (this.getSubscription(headers.subscription) !== null) {
                this.getSubscription(headers.subscription)
                    .error(payload);
            }
        }
    }
    create(config, messageHeaders) {
        this._config = config;
        this._socketConnected = false;
        this._stompConnectedObserver = new Subject(); // rebuild for every connection
        this.currentConnectionState = ConnectionState.Connecting;
        let ws;
        ws = this._config.generateSocket();
        ws.binaryType = 'arraybuffer';
        // create local observers for socket events
        this._socketOpenObserver = fromEvent(ws, 'open')
            .pipe(map((response) => {
            return response;
        }));
        this._socketCloseObserver = fromEvent(ws, 'close')
            .pipe(map((response) => {
            return { event: response, config: config };
        }));
        this._socketErrorObserver = fromEvent(ws, 'error')
            .pipe(map((response) => {
            return response;
        }));
        // wire observers.
        this._socketMessageObserver = fromEvent(ws, 'message')
            .pipe(map((response) => {
            return response;
        }));
        this._socketOpenObserver
            .subscribe((evt) => this.onOpen(evt, messageHeaders));
        this._socketMessageObserver
            .subscribe((evt) => this.onMessage(evt));
        this._socketCloseObserver
            .subscribe((evt) => this.onClose(config));
        this._socketErrorObserver
            .subscribe((err) => this.onError(err));
        this._socket = ws;
        return this._stompConnectedObserver;
    }
}
StompClient.STOMP_CONFIGURED = 'CONFIGURED';
StompClient.STOMP_CONNECT = 'CONNECT';
StompClient.STOMP_CONNECTED = 'CONNECTED';
StompClient.STOMP_CONNECTED_DUPLICATE = 'CONNECTED_DUPLICATE';
StompClient.STOMP_MESSAGE = 'MESSAGE';
StompClient.STOMP_RECEIPT = 'RECEIPT';
StompClient.STOMP_DISCONNECT = 'DISCONNECT';
StompClient.STOMP_DISCONNECTING = 'DISCONNECTING';
StompClient.STOMP_DISCONNECTED = 'DISCONNECTED';
StompClient.STOMP_SUBSCRIBE = 'SUBSCRIBE';
StompClient.STOMP_SUBSCRIBED = 'SUBSCRIBED';
StompClient.STOMP_UNSUBSCRIBE = 'UNSUBSCRIBE';
StompClient.STOMP_UNSUBSCRIBED = 'UNSUBSCRIBED';
StompClient.STOMP_INVALIDMONITOR = 'INVALID_MONITOR';
StompClient.STOMP_SEND = 'SEND';
StompClient.STOMP_ACK = 'ACK';
StompClient.STOMP_BEGIN = 'BEGIN';
StompClient.STOMP_ABORT = 'ABORT';
StompClient.STOMP_ERROR = 'ERROR';
StompClient.STOMP_COMMIT = 'COMMIT';
//# sourceMappingURL=stomp.client.js.map