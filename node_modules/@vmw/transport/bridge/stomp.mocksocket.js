/*
 * Copyright 2017-2018 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { StompClient } from './stomp.client';
import { StompParser } from './stomp.parser';
export class MockSocket {
    constructor(url, protocols) {
        this.url = url;
        this.protocols = protocols;
        this.events = {};
        this._socketState = WebSocket.OPEN;
        this.transaction = false;
        // fire once the mock socket has been created and returned.
        setTimeout(() => this.triggerEvent('open', [true]), 0);
    }
    set binaryType(bt) {
        this._binaryType = bt;
    }
    get binaryType() {
        return this._binaryType;
    }
    set socketState(state) {
        this._socketState = state;
    }
    get readyState() {
        return this._socketState;
    }
    send(data) {
        let frame = StompParser.unmarshal(data);
        switch (frame.command) {
            case StompClient.STOMP_CONNECT:
                setTimeout(() => {
                    this._socketState = WebSocket.OPEN;
                    this.triggerEvent('message', [{
                            data: StompParser.marshal(StompClient.STOMP_CONNECTED, {}, '')
                        }]);
                }, 0);
                break;
            case StompClient.STOMP_SEND:
                if (!this.transaction) {
                    setTimeout(() => {
                        this.triggerEvent('message', [{
                                data: StompParser.marshal(StompClient.STOMP_MESSAGE, frame.headers, frame.body)
                            }]);
                    }, 0);
                }
                break;
            case StompClient.STOMP_BEGIN:
                this.transaction = true;
                this.transactionId = frame.headers.transaction;
                this.receiptId = frame.headers.receipt;
                break;
            case StompClient.STOMP_COMMIT:
                this.transaction = false;
                setTimeout(() => {
                    this.triggerEvent('message', [{
                            data: StompParser.marshal(StompClient.STOMP_RECEIPT, { 'receipt-id': this.receiptId })
                        }]);
                }, 0);
                break;
            case StompClient.STOMP_ABORT:
                this.transaction = false;
                setTimeout(() => {
                    this.triggerEvent('message', [{
                            data: StompParser.marshal(StompClient.STOMP_RECEIPT, { 'receipt-id': this.receiptId })
                        }]);
                }, 0);
                break;
            case StompClient.STOMP_ERROR:
                this.transaction = false;
                setTimeout(() => {
                    this.triggerEvent('message', [{
                            data: StompParser.marshal(StompClient.STOMP_ERROR, frame.headers, frame.body)
                        }]);
                }, 0);
                break;
            case StompClient.STOMP_DISCONNECT:
                setTimeout(() => {
                    this._socketState = WebSocket.CLOSED;
                    this.triggerEvent('close');
                }, 0);
                break;
            default:
                break;
        }
    }
    close() {
        // do nothing.
    }
    addEventListener(name, handler) {
        if (this.events.hasOwnProperty(name)) {
            this.events[name].push(handler); // reassign
        }
        else {
            this.events[name] = [handler]; // assign
        }
    }
    removeEventListener(name) {
        if (this.events.hasOwnProperty(name)) {
            delete this.events[name];
        }
    }
    triggerEvent(name, args) {
        if (!this.events.hasOwnProperty(name)) {
            return;
        }
        if (!args || !args.length) {
            args = [];
        }
        let events = this.events[name], l = events.length;
        for (let i = 0; i < l; i++) {
            events[i].apply(null, args); //fire
        }
        return this;
    }
}
//# sourceMappingURL=stomp.mocksocket.js.map