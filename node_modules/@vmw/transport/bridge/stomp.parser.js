/*
 * Copyright 2017-2019 VMware, Inc.
 * SPDX-License-Identifier: BSD-2-Clause
 */
import { GeneralUtil } from '../util/util';
export class StompParser {
    // http://stackoverflow.com/questions/6965107/converting-between-strings-and-arraybuffers
    static bufferToString(buf) {
        return String.fromCharCode.apply(null, new Uint16Array(buf));
    }
    static stringToArrayBuffer(str) {
        let buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
        let bufView = new Uint16Array(buf);
        for (let i = 0, strLen = str.length; i < strLen; i++) {
            bufView[i] = str.charCodeAt(i);
        }
        return buf;
    }
    static marshal(command, headers, body) {
        return StompParser.frame(command, headers, body).toString() + '\0';
    }
    static unmarshal(data) {
        let divider = data.search(/\n\n/);
        let headerLines = data.substring(0, divider).split('\n');
        let command = headerLines.shift();
        let headers = {};
        let body = '';
        // Parse headers
        let line, idx = null;
        for (let i = 0; i < headerLines.length; i++) {
            line = headerLines[i];
            idx = line.indexOf(':');
            headers[StompParser.trim(line.substring(0, idx))] =
                StompParser.trim(line.substring(idx + 1));
        }
        // Parse body, stopping at the first \0 found.
        let chr = null;
        for (let i = divider + 2; i < data.length; i++) {
            chr = data.charAt(i);
            if (chr === '\0') {
                break;
            }
            body += chr;
        }
        return StompParser.frame(command, headers, body);
    }
    static byteCount(str) {
        str = String(str);
        let bLen = 0;
        for (let i = 0; i < str.length; i++) {
            let c = str.charCodeAt(i);
            bLen += c < (1 << 7) ? 1 :
                c < (1 << 11) ? 2 :
                    c < (1 << 16) ? 3 :
                        c < (1 << 21) ? 4 :
                            c < (1 << 26) ? 5 :
                                c < (1 << 31) ? 6 : Number.NaN;
        }
        return bLen;
    }
    static frame(command, headers, body) {
        if (body instanceof ArrayBuffer) {
            body = StompParser.bufferToString(body);
        }
        let parsedBody;
        if (typeof body === 'object') {
            parsedBody = JSON.stringify(body);
        }
        else {
            parsedBody = body;
        }
        return {
            command: command,
            headers: headers,
            body: body,
            toString: () => {
                let out = command + '\n';
                if (headers) {
                    for (let header in headers) {
                        if (headers.hasOwnProperty(header)) {
                            out = out + header + ':' + headers[header] + '\n';
                        }
                    }
                }
                out = out + 'accept-version:1.2\n'; // hard wire this in, mandatory for spring 5.1.6+
                if (body) {
                    // build content-length not implemtened in original library
                    if (command === 'SEND') {
                        //out = out + 'content-length: ' +
                        //StompParser.byteCount(parsedBody.trim())  + '\n';
                    }
                }
                out = out + '\n';
                if (body) {
                    out = out + parsedBody.trim();
                }
                return out;
            }
        };
    }
    static trim(str) {
        return str.replace(/^\s+/g, '').replace(/\s+$/g, '');
    }
    /**
     * @deprecated Use GeneraUtil
     */
    static genUUID() {
        return GeneralUtil.genUUID();
    }
    /**
     * @deprecated Use GeneraUtil
     */
    static genUUIDShort() {
        return GeneralUtil.genUUIDShort();
    }
    // extract a bus command from a bus message.
    static extractStompBusCommandFromMessage(msg) {
        if (msg !== null) {
            return msg.payload;
        }
        return null;
    }
    // extract a stomp message from a stomp command message.
    static extractStompMessageFromBusCommand(cmd) {
        if (cmd !== null) {
            return cmd.payload;
        }
        return null;
    }
    // extract a stomp message from a bus message.
    static extractStompMessageFromBusMessage(msg) {
        if (msg !== null) {
            return StompParser.extractStompMessageFromBusCommand(StompParser
                .extractStompBusCommandFromMessage(msg));
        }
        return null;
    }
    // shortcut for creating bus commands for subscription requests
    static generateStompBrokerSubscriptionRequest(sessionId, destination, subscriptionId, isQueue, brokerPrefix) {
        return {
            session: sessionId,
            destination: destination,
            id: subscriptionId,
            isQueue: isQueue,
            brokerPrefix: brokerPrefix
        };
    }
    // shortcut for creating bus commands
    static generateStompBusCommand(command, sessionId, destination, payload) {
        return {
            destination: destination,
            session: sessionId,
            command: command,
            payload: payload
        };
    }
    // shortcut for generating outbound messages (messages to be sent to the broker)
    static generateStompReadyMessage(message, headers) {
        let header = headers || {};
        return StompParser.frame('SEND', header, message);
    }
    // remove channel-hash
    static convertChannelToSubscription(channel) {
        // TODO: we need to create rules for channel creation.
        //return channel.replace("#","").toLowerCase().trim();
        return channel.trim();
    }
    // create galactic topic/queue detination
    static generateGalacticDesintation(dest, channel) {
        return dest + '/' + channel;
    }
    // convert destination back into a channel
    static convertSubscriptionToChannel(subscription, topicOrQueueDesintation) {
        return subscription.replace(topicOrQueueDesintation + '/', '');
    }
    // convert topic/queue back into a channel
    static convertTopicOrQueueToChannel(subscription, brokerPrefix) {
        return subscription.replace(brokerPrefix + '/', '').trim();
    }
}
//# sourceMappingURL=stomp.parser.js.map